/*<ATGCOPYRIGHT>
 * Copyright (C) 1997-2011 Art Technology Group, Inc.
 * All Rights Reserved.  No use, copying or distribution ofthis
 * work may be made except in accordance with a valid license
 * agreement from Art Technology Group.  This notice must be
 * included on all copies, modifications and derivatives of this
 * work.
 *
 * Art Technology Group (ATG) MAKES NO REPRESENTATIONS OR WARRANTIES
 * ABOUT THE SUITABILITY OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. ATG SHALL NOT BE
 * LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING,
 * MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
 *
 * "Dynamo" is a trademark of Art Technology Group, Inc.
 </ATGCOPYRIGHT>*/

package atg.commerce.pricing;

import java.math.BigDecimal;
import java.text.DecimalFormatSymbols;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import javax.jms.JMSException;

import atg.beans.DynamicBeans;
import atg.beans.PropertyNotFoundException;
import atg.commerce.CommerceException;
import atg.commerce.catalog.CatalogTools;
import atg.commerce.messaging.MessageSender;
import atg.commerce.messaging.SourceSinkTemplate;
import atg.commerce.order.AuxiliaryData;
import atg.commerce.order.CommerceIdentifier;
import atg.commerce.order.CommerceItem;
import atg.commerce.order.CommerceItemContainer;
import atg.commerce.order.CommerceItemManager;
import atg.commerce.order.CommerceItemRelationship;
import atg.commerce.order.Order;
import atg.commerce.order.OrderManager;
import atg.commerce.order.OrderTools;
import atg.commerce.order.ShippingGroup;
import atg.commerce.order.ShippingGroupCommerceItemRelationship;
import atg.commerce.pricing.priceLists.PriceListException;
import atg.commerce.pricing.priceLists.PriceListManager;
import atg.core.util.DictionaryThread;
import atg.core.util.DictionaryThreadKey;
import atg.core.util.Range;
import atg.core.util.RangeComparator;
import atg.core.util.ResourceUtils;
import atg.multisite.SiteContextManager;
import atg.nucleus.ServiceException;
import atg.repository.MutableRepository;
import atg.repository.RepositoryException;
import atg.repository.RepositoryItem;
import atg.service.idgen.IdGenerator;
import atg.service.idgen.IdGeneratorException;
import atg.service.perfmonitor.PerfStackMismatchException;
import atg.service.perfmonitor.PerformanceMonitor;
import atg.servlet.RequestLocale;
import atg.servlet.ServletUtil;
/**
 * A class which can perform a variety of pricing functions across different types of
 * PricingEngine.  It simplifies interaction with a spectrum of PricingEngines.
 * It also has a number of static currency-related methods for use by all pricing engines.
 * <p>
 *
 * The pricing engines themselves are not tasked with assigning prices to a given CommerceItem.
 * ShippingGroup or Order. They generate "quotes" whose price info objects can then be associated
 * with the objects. The pricing methods in this class are designed to perform that association
 * for the developer automatically. For example, if one invokes the <code>priceOrderTotal</code>
 * method that will execute the Item Pricing Engine, assign each <code>ItemPriceInfo</code> to
 * each CommerceItem, then execute the Shipping Pricing Engine, and assign all shipping costs
 * to the ShippingGroups, calculate the order subtotal through the Order Pricing Engine, and
 * determine the amount of taxes owed through the Tax Pricing Engine. Finally it takes the
 * shipping and tax totals and assigns those into the <code>OrderPriceInfo</code> object of the
 * order supplied.
 * <P>
 * The other methods follow the same methodology, where they generate a quote from a pricing engine
 * and then assign that new price to the object.
 * <P>
 * There are three main ways one can supply pricing models for pricing. Each type of pricing has
 * overloaded methods which perform these three different styles.
 * <OL>
 * <LI>Extract the pricing models from the profile through the pricing engine
 * <LI>Retrieve the correct pricing models from the PricingModelHolder, which "caches" the lists
 * of pricing models generated by the pricing engines in the user's session
 * <LI>Directly supplying the collection of pricing models
 * </OL>
 *
 * <P>
 * Properties:
 * <ul>
 *  <li><b>itemPricingEngine</b> points to an instance of an ItemPricingEngine for use
 *      by pricingTools methods that need an ItemPricingEngine.
 *  <li><b>orderPricingEngine</b> points to an instance of an OrderPricingEngine for use
 *      by pricingTools methods that need an OrderPricingEngine.
 *  <li><b>taxPricingEngine</b> points to an instance of an TaxPricingEngine for use
 *      by pricingTools methods that need an TaxPricingEngine.
 *  <li><b>shippingPricingEngine</b> points to an instance of an ShippingPricingEngine for use
 *      by pricingTools methods that need an ShippingPricingEngine.
 *  <li><b>defaultLocale</b> is the locale that's used to price Orders, Items, Shipping, and Tax
 *      if no other locale is explicitly specified.
 * </ul>
 *
 * @see ItemPricingEngine
 * @see TaxPricingEngine
 * @see ShippingPricingEngine
 * @see OrderPricingEngine
 *
 * @author Bob Mason
 * @version $Id: //product/DCS/version/10.0.3/Java/atg/commerce/pricing/PricingTools.java#2 $$Change: 651448 $
 * @updated $DateTime: 2011/06/07 13:55:45 $$Author: rbarbier $
 */

public
class PricingTools
extends SourceSinkTemplate
{
  //-------------------------------------
  /** Class version string */
  public static String CLASS_VERSION =
    "$Id: //product/DCS/version/10.0.3/Java/atg/commerce/pricing/PricingTools.java#2 $$Change: 651448 $";

  //-------------------------------------
  // Constants
  //-------------------------------------
  public static final String DETAILED_ITEM_PRICE_AMOUNT_PROPERTY = "amount";
  public static final String DETAILED_ITEM_PRICE_ORDER_DISCOUNT_SHARE_PROPERTY = "orderDiscountShare";
  public static final String DETAILED_ITEM_PRICE_ORDER_MANUAL_ADJUSTMENT_SHARE_PROPERTY = "orderManualAdjustmentShare";
  private static final String PERFORM_MONITOR_NAME="PricingTools";
  static final String MY_RESOURCE_NAME = "atg.commerce.pricing.Resources";

  /** Resource Bundle **/
  private static java.util.ResourceBundle sResourceBundle =
    java.util.ResourceBundle.getBundle(MY_RESOURCE_NAME, atg.service.dynamo.LangLicense.getLicensedDefault());

  //-------------------------------------
  // Member Variables
  //-------------------------------------
  static Map sDecimalFormatSymbols = new HashMap();


  /** The key into the DictionaryThread for the the Dynamo request */
  class CommerceItemKey implements DictionaryThreadKey {
    public Object createObject () {
      return new PricingCommerceItem();
    }
  }

  DictionaryThreadKey mCommerceItemKey = new CommerceItemKey();

  //-------------------------------------
  // Properties
  //-------------------------------------

  protected ItemPriceSourceHandler[] mItemPriceSourceHandlers;
  /**
   * Configures an array of <code>ItemPriceSourceHandler</code> components
   * that are used to generate price overrides.
   * <p>
   * If null, this method will dynamically build the array of handlers from the
   * ItemPriceEngine's preCalculators.
   * 
   * @see #generateItemPriceSources(Order, Map)
   * @return an array of ItemPriceSourceHandlers
   */
  public ItemPriceSourceHandler[] getItemPriceSourceHandlers()
  {
    if(mItemPriceSourceHandlers == null)
    {
      ArrayList handlers = new ArrayList();
      if(getItemPricingEngine() instanceof ItemPricingEngineImpl)
      {
        ItemPricingEngineImpl engine = (ItemPricingEngineImpl)getItemPricingEngine();
        ItemPricingCalculator[] precalcs = engine.getPreCalculators();
        for(int i=0;i < precalcs.length; i++)
        {
          ItemPricingCalculator calc = (ItemPricingCalculator) precalcs[i];
          if(calc instanceof ItemPriceSourceHandler)
            handlers.add(calc);
        }
      }
      mItemPriceSourceHandlers= new ItemPriceSourceHandler[handlers.size()];
      for(int i=0;i < handlers.size(); i++)
        mItemPriceSourceHandlers[i] = (ItemPriceSourceHandler)handlers.get(i);
      
    }
    
    return mItemPriceSourceHandlers;
  }

  public void setItemPriceSourceHandlers(
      ItemPriceSourceHandler[] pItemPriceSourceHandlers)
  {
    mItemPriceSourceHandlers = pItemPriceSourceHandlers;
  }
  
  
  //---------------------------------------------------------------------------
  // property: PricingContextFactory
  //---------------------------------------------------------------------------

  private PricingContextFactory mPricingContextFactory = new PricingContextFactory();
  public void setPricingContextFactory(PricingContextFactory pPricingContextFactory) {
    mPricingContextFactory = pPricingContextFactory;
  }

  /**
   * Factory to create PricingContext instances
   **/
  public PricingContextFactory getPricingContextFactory() {
    return mPricingContextFactory;
  }

  //---------------------------------------------------------------------------
  // property:CommerceItemManager
  //---------------------------------------------------------------------------

  private CommerceItemManager mCommerceItemManager;
  public void setCommerceItemManager(CommerceItemManager pCommerceItemManager) {
    mCommerceItemManager = pCommerceItemManager;
  }

  /**
   * Manager class used to manipulate commerce items
   **/
  public CommerceItemManager getCommerceItemManager() {
    return mCommerceItemManager;
  }


  //---------------------------------------------------------------------------
  // property:OrderManager
  //---------------------------------------------------------------------------

  private OrderManager mOrderManager;
  public void setOrderManager(OrderManager pOrderManager) {
    mOrderManager = pOrderManager;
  }

  /**
   * Manager class used to manipulate commerce items
   **/
  public OrderManager getOrderManager() {
    return mOrderManager;
  }


  //---------------------------------------------------------------------------
  // property:RangeClassType
  //---------------------------------------------------------------------------

  private String mRangeClassType = "atg.core.util.Range";
  public void setRangeClassType(String pRangeClassType) {
    mRangeClassType = pRangeClassType;
  }

  /**
   * The class used when creating range objects.  It must be a subclass of
   * atg.core.util.Range
   **/
  public String getRangeClassType() {
    return mRangeClassType;
  }

  //-------------------------------------
  // property: RoundingDecimalPlaces
  /** number of decimal places to which prices should be rounded */
  int mRoundingDecimalPlaces = 2;

  /**
   * number of decimal places to which prices should be rounded
   * @beaninfo description: number of decimal places to which prices should be rounded
   * @param pRoundingDecimalPlaces new value to set
   */
  public void setRoundingDecimalPlaces(int pRoundingDecimalPlaces)
  {mRoundingDecimalPlaces = pRoundingDecimalPlaces;}

  /**
   * number of decimal places to which prices should be rounded
   * @beaninfo description: number of decimal places to which prices should be rounded
   * @return property RoundingDecimalPlaces
   */
  public int getRoundingDecimalPlaces()
  {return mRoundingDecimalPlaces;}


  //-------------------------------------
  // property: LoggingIdentifier
  String mLoggingIdentifier = "PricingTools";

  /**
   * Sets property LoggingIdentifier
   **/
  public void setLoggingIdentifier(String pLoggingIdentifier) {
    mLoggingIdentifier = pLoggingIdentifier;
  }

  /**
   * Returns property LoggingIdentifier
   **/
  public String getLoggingIdentifier() {
    return mLoggingIdentifier;
  }


  //-------------------------------------
  // property: SubSkuPriceInfoClass
  Class mSubSkuPriceInfoClass;

  /**
   * Sets property SubSkuPriceInfoClass
   * @beaninfo
   *   description: The name of the class to store for the results of pricing for subskus.
   *   expert: true
   **/
  public void setSubSkuPriceInfoClass(Class pSubSkuPriceInfoClass) {
    mSubSkuPriceInfoClass = pSubSkuPriceInfoClass;
  }

  /**
   * Returns property PriceInfoClass
   **/
  public Class getSubSkuPriceInfoClass() {
    return mSubSkuPriceInfoClass;
  }


  //-------------------------------------
  // property: ItemPricingEngine
  ItemPricingEngine mItemPricingEngine;

  /**
   * Sets property ItemPricingEngine
   **/
  public void setItemPricingEngine(ItemPricingEngine pItemPricingEngine) {
    mItemPricingEngine = pItemPricingEngine;
  }

  /**
   * Returns property ItemPricingEngine
   **/
  public ItemPricingEngine getItemPricingEngine() {
    return mItemPricingEngine;
  }

  //-------------------------------------
  // property: OrderPricingEngine
  OrderPricingEngine mOrderPricingEngine;

  /**
   * Sets property OrderPricingEngine
   **/
  public void setOrderPricingEngine(OrderPricingEngine pOrderPricingEngine) {
    mOrderPricingEngine = pOrderPricingEngine;
  }

  /**
   * Returns property OrderPricingEngine
   **/
  public OrderPricingEngine getOrderPricingEngine() {
    return mOrderPricingEngine;
  }

  //-------------------------------------
  // property: TaxPricingEngine
  TaxPricingEngine mTaxPricingEngine;

  /**
   * Sets property TaxPricingEngine
   **/
  public void setTaxPricingEngine(TaxPricingEngine pTaxPricingEngine) {
    mTaxPricingEngine = pTaxPricingEngine;
  }

  /**
   * Returns property TaxPricingEngine
   **/
  public TaxPricingEngine getTaxPricingEngine() {
    return mTaxPricingEngine;
  }

  //-------------------------------------
  // property: ShippingPricingEngine
  ShippingPricingEngine mShippingPricingEngine;

  /**
   * Sets property ShippingPricingEngine
   **/
  public void setShippingPricingEngine(ShippingPricingEngine pShippingPricingEngine) {
    mShippingPricingEngine = pShippingPricingEngine;
  }

  /**
   * Returns property ShippingPricingEngine
   **/
  public ShippingPricingEngine getShippingPricingEngine() {
    return mShippingPricingEngine;
  }

  MutableRepository mProfileRepository;
  public void setProfileRepository(MutableRepository pProfileRepository) {
    mProfileRepository = pProfileRepository;
  }

  public MutableRepository getProfileRepository() {
    return mProfileRepository;
  }

  String mProfileItemType;
  public void setProfileItemType(String pProfileItemType) {
    mProfileItemType = pProfileItemType;
  }

  public String getProfileItemType() {
    return mProfileItemType;
  }

  //---------------------------------------------------------------------------
  // property:ShippingSubtotalUsesAverageItemPrice
  //---------------------------------------------------------------------------

  private boolean mShippingSubtotalUsesAverageItemPrice = true;
  public void setShippingSubtotalUsesAverageItemPrice(boolean pShippingSubtotalUsesAverageItemPrice) {
    mShippingSubtotalUsesAverageItemPrice = pShippingSubtotalUsesAverageItemPrice;
  }

  /**
   * If true, a shipping groups subtotal is calculated by multiplying
   * each item prices' average by the quantity in the given shipping
   * group.  If false, the shipping group subtotal is calculated using
   * <code>PricingTools.getShipItemRelSubtotal</code>
   * <P>
   * default value is true
   * @beaninfo description: If true, a shipping groups subtotal is calculated by multiplying
   *                        each item prices' average by the quantity in the given shipping
   *                        group.  If false, the shipping group subtotal is calculated using
   *                        PricingTools.getShipItemRelSubtotal
   **/
  public boolean isShippingSubtotalUsesAverageItemPrice() {
    return mShippingSubtotalUsesAverageItemPrice;
  }

  //---------------------------------------------------------------------------
  // property:RangeComparator
  //---------------------------------------------------------------------------

  private RangeComparator mRangeComparator = new RangeComparator();
  public void setRangeComparator(RangeComparator pRangeComparator) {
    mRangeComparator = pRangeComparator;
  }

  /**
   * The object that is used to compare ranges
   **/
  public RangeComparator getRangeComparator() {
    return mRangeComparator;
  }

  //-------------------------------------
  // property: DefaultLocale
  Locale mDefaultLocale;

  /**
   * Sets property DefaultLocale
   **/
  public void setDefaultLocale(Locale pDefaultLocale) {
    mDefaultLocale = pDefaultLocale;
  }

  /**
   * Returns property DefaultLocale. If the property value is null, then
   * JVM's default locale is returned.
   **/
  public Locale getDefaultLocale() {
    if (mDefaultLocale != null)
      return mDefaultLocale;
    else
      return Locale.getDefault();
  }


  //---------------------------------------------------------------------------
  // property:DetailedItemPriceTools
  //---------------------------------------------------------------------------

  private DetailedItemPriceTools mDetailedItemPriceTools;

  /**
   * The class for providing various methods for manipulating DetailedItemPriceInfos
   **/
  public DetailedItemPriceTools getDetailedItemPriceTools() {
    if(mDetailedItemPriceTools == null)
      mDetailedItemPriceTools = new DetailedItemPriceTools(this);
    return mDetailedItemPriceTools;
  }



  //---------------------------------------------------------------------------
  // property:DetailedItemPriceInfoClass
  //---------------------------------------------------------------------------

  private Class mDetailedItemPriceInfoClass = null;
  public void setDetailedItemPriceInfoClass(Class pDetailedItemPriceInfoClass) {
    mDetailedItemPriceInfoClass = pDetailedItemPriceInfoClass;
  }

  /**
   * The class that is used for detailed item price infos.  The value
   * must be a subtype of DetailedItemPriceInfo
   **/
  public Class getDetailedItemPriceInfoClass() {
    return mDetailedItemPriceInfoClass;
  }

  //---------------------------------------------------------------------------
  // property:GeneratePriceChangedEvents
  //---------------------------------------------------------------------------

  private boolean mGeneratePriceChangedEvents;
  public void setGeneratePriceChangedEvents(boolean pGeneratePriceChangedEvents) {
    mGeneratePriceChangedEvents = pGeneratePriceChangedEvents;
  }

  /**
   * If this is true, whenever an order gets repriced and the price
   * is different, a PriceChanged event will be sent
   * @see atg.commerce.pricing.PriceChanged
   **/
  public boolean isGeneratePriceChangedEvents() {
    return mGeneratePriceChangedEvents;
  }

  //---------------------------------------------------------------------------
  // property:MessageIdGenerator
  //---------------------------------------------------------------------------

  private IdGenerator mMessageIdGenerator;
  public void setMessageIdGenerator(IdGenerator pMessageIdGenerator) {
    mMessageIdGenerator = pMessageIdGenerator;
  }

  /**
   * The service that generates Ids for all messages.
   **/
  public IdGenerator getMessageIdGenerator() {
    return mMessageIdGenerator;
  }


  //---------------------------------------------------------------------------
  // property:MessageIdSpaceName
  //---------------------------------------------------------------------------

  private String mMessageIdSpaceName;
  public void setMessageIdSpaceName(String pMessageIdSpaceName) {
    mMessageIdSpaceName = pMessageIdSpaceName;
  }

  /**
   * The name of the idspace to get our message ids from
   **/
  public String getMessageIdSpaceName() {
    return mMessageIdSpaceName;
  }


  //---------------------------------------------------------------------------
  // property:ScenarioEventPort
  //---------------------------------------------------------------------------

  private String mScenarioEventPort;
  public void setScenarioEventPort(String pScenarioEventPort) {
    mScenarioEventPort = pScenarioEventPort;
  }

  /**
   * The name of the port to send pricing events to
   **/
  public String getScenarioEventPort() {
    return mScenarioEventPort;
  }

  //---------------------------------------------------------------------------
  // property:SendEventsWithNoProfile
  //---------------------------------------------------------------------------

  private boolean mSendEventsWithNoProfile = false;
  public void setSendEventsWithNoProfile(boolean pSendEventsWithNoProfile) {
    mSendEventsWithNoProfile = pSendEventsWithNoProfile;
  }

  /**
   * It is possible for some orders to have a null profile (if the
   * user was anonymous).  If this property is false, those event on
   * those orders will not be sent.  If true, all events are sent,
   * regardless of the order's profile.
   * The default value is false.
   **/
  public boolean isSendEventsWithNoProfile() {
    return mSendEventsWithNoProfile;
  }


  //---------------------------------------------------------------------------
  // property:CatalogTools
  //---------------------------------------------------------------------------
  private CatalogTools mCatalogTools;
  public void setCatalogTools(CatalogTools pCatalogTools) {
    mCatalogTools = pCatalogTools;
  }

  /**
   * The CatalogTools used to retrieve skus and products
   **/
  public CatalogTools getCatalogTools() {
    return mCatalogTools;
  }
  //---------------------------------------------------------------------------
  // property:OrderTools
  //---------------------------------------------------------------------------

  private OrderTools mOrderTools;
  public void setOrderTools(OrderTools pOrderTools) {
    mOrderTools = pOrderTools;
  }

  /**
   * The order tools from which to get the default itemPriceInfo class
   **/
  public OrderTools getOrderTools() {
    return mOrderTools;
  }

  //---------------------------------------------------------------------------
  // property:UseDefaultLocaleIfNotSpecified
  //---------------------------------------------------------------------------

  private boolean mUseDefaultLocaleIfNotSpecified=false;
  public void setUseDefaultLocaleIfNotSpecified(boolean pUseDefaultLocaleIfNotSpecified) {
    mUseDefaultLocaleIfNotSpecified = pUseDefaultLocaleIfNotSpecified;
  }

  /**
   * Whether to use the default locale if one is not specified
   **/
  public boolean isUseDefaultLocaleIfNotSpecified() {
    return mUseDefaultLocaleIfNotSpecified;
  }


  //-------------------------------------
  // property: closenessQualificationMessageSender
  MessageSender mClosenessQualificationMessageSender;

  /**
   * Sets the component that fires PromotionClosenessQualification and
   * PromotionClosenessDisqualification events
   * @param pMessageSender the component that fires PromotionClosenessQualification
   *        and PromotionClosenessDisqualification events 
   **/
  public void setClosenessQualificationMessageSender(MessageSender pClosenessQualificationMessageSender) {
    mClosenessQualificationMessageSender = pClosenessQualificationMessageSender;
  }

  /**
   * @return the component that fires PromotionClosenessQualification and
   *         PromotionClosenessDisqualification events
   **/
  public MessageSender getClosenessQualificationMessageSender() {
    return mClosenessQualificationMessageSender;
  }

  //-------------------------------------
  // property: promotionClosenessDisqualificationJMSType
  String mPromotionClosenessDisqualificationJMSType;

  /**
   * Sets the JMS type of the PromotionClosenessDisqualification message
   * @param pPromotionClosenessDisqualificationJMSType the JMS type of the
   *        PromotionClosenessDisqualificationMessage
   **/
  public void setPromotionClosenessDisqualificationJMSType(String pPromotionClosenessDisqualificationJMSType) {
    mPromotionClosenessDisqualificationJMSType = pPromotionClosenessDisqualificationJMSType;
  }

  /**
   * @return the JMS type of the PromotionClosenessDisqualification message
   **/
  public String getPromotionClosenessDisqualificationJMSType() {
    return mPromotionClosenessDisqualificationJMSType;
  }

  //-------------------------------------
  // property: promotionClosenessQualificationJMSType
  String mPromotionClosenessQualificationJMSType;

  /**
   * Sets the JMS type of the PromotionClosenessQualification message
   * @param pPromotionClosenessQualificationJMSType the JMS type of the
   *        PromotionClosenessQualificationMessage
   **/
  public void setPromotionClosenessQualificationJMSType(String pPromotionClosenessQualificationJMSType) {
    mPromotionClosenessQualificationJMSType = pPromotionClosenessQualificationJMSType;
  }

  /**
   * @return the JMS type of the PromotionClosenessQualification message
   **/
  public String getPromotionClosenessQualificationJMSType() {
    return mPromotionClosenessQualificationJMSType;
  }

  //-------------------------------------
  // property: sendPromotionClosenessMessages
  boolean mSendPromotionClosenessMessages;

  /**
   * boolean indicating if the promotion-closeness JMS messages should be sent.
   * @param pSendPromotionClosenessMessages boolean indicating if the 
   *        promotion-closeness JMS messages should be sent.
   **/
  public void setSendPromotionClosenessMessages(boolean pSendPromotionClosenessMessages) {
    mSendPromotionClosenessMessages = pSendPromotionClosenessMessages;
  }

  /**
   * @return boolean indicating if the promotion-closeness JMS messages should be sent.
   **/
  public boolean isSendPromotionClosenessMessages() {
    return mSendPromotionClosenessMessages;
  }

  //---------------------------------------------------------------------------
  // property: PriceListManager
  /** the reference to the PriceListManager*/ 
  PriceListManager mPriceListManager = null;

  /**
   * Sets property PriceListManager which handles the operations of the PriceList
   * @param pPriceListManager the new value to set
   */
  public void setPriceListManager(PriceListManager pPriceListManager) {
    mPriceListManager = pPriceListManager;
  }

  /**
   * Returns the reference to the PriceListManager which handles the operations of the PriceList
   * @return the reference to the PriceListManager
   * @beaninfo description: Returns the reference to the PriceListManager
   */
  public PriceListManager getPriceListManager() {
    return mPriceListManager;
  }

  //---------------------------------------------------------------------------
  // property: UsePassedLocaleAsPricingLocale
  /** the boolean value usePassedLocaleAsPricingLocale */ 
  boolean mUsePassedLocaleAsPricingLocale = false;

  /**
   * Sets property usePassedLocaleAsPricingLocale which if true means getPricingLocale will 
   * just return the locale passed into it rather than trying to determine it from the price list
   * or the default
   * Defaults to false.
   * @param pUsePassedLocaleAsPricingLocale the new boolean value to set
   */
  public void setUsePassedLocaleAsPricingLocale(boolean pUsePassedLocaleAsPricingLocale) {
    mUsePassedLocaleAsPricingLocale = pUsePassedLocaleAsPricingLocale;
  }

  /**
   * Returns the boolean value of usePassedLocaleAsPricingLocale which if true means getPricingLocale will 
   * just return the locale passed into it.
   * Defaults to false.
   * @return the boolean value of usePassedLocaleAsPricingLocale
   * @beaninfo description: Returns the boolean value of usePassedLocaleAsPricingLocale
   */
  public boolean isUsePassedLocaleAsPricingLocale() {
    return mUsePassedLocaleAsPricingLocale;
  }

  //---------------------------------------------------------------------------
  // property: usingPriceLists
  protected boolean mUsingPriceLists = false;
  private boolean mUsingPriceListsExplicitlySet = false;

  /**
   * Sets property usingPriceLists, which indicates whether the application uses price lists
   * or SKU-based pricing.
   * If not explicitly configured, the value is determined at startup based on which
   * ItemPricingCalculators are configured.
   * @param pUsingPriceLists the new boolean value to set
   */
  public void setUsingPriceLists(boolean pUsingPriceLists) {
    mUsingPriceLists = pUsingPriceLists;
    mUsingPriceListsExplicitlySet = true;
  }

  /**
   * Sets property usingPriceLists, which indicates whether the application uses price lists
   * or SKU-based pricing.
   * If not explicitly configured, the value is determined at startup based on which
   * ItemPricingCalculators are configured.
   * @return the boolean value of usingPriceLists
   * @beaninfo description: Returns the boolean value of usingPriceLists
   */
  public boolean isUsingPriceLists() {
    return mUsingPriceLists;
  }

  /**
   * This will return true if the value of <code>usingPriceLists</code> has been
   * explicitly set either through code or through a properties file.
   * @return the boolean value of usingPriceListsExplicitlySet
   */
  public boolean isUsingPriceListsExplicitlySet() {
    return mUsingPriceListsExplicitlySet;
  }

  //-------------------------------------
  // Constructors
  //-------------------------------------

  /**
   * Constructs an instanceof PricingTools
   */
  public PricingTools() {
  }

  /**
   * Derives some property values based on configuration settings
   */
  public void doStartService()
  throws ServiceException
  {
    deriveUsingPriceLists();
  }

  /**
   * Figure out if the system is configured to use price lists or not.
   * Honor explicit configuration if it was provided.
   */
  public void deriveUsingPriceLists()
  {
    if (!isUsingPriceListsExplicitlySet()) {
      mUsingPriceLists = false;
      if (getItemPricingEngine() instanceof ItemPricingEngineImpl &&
          getPriceListManager() != null) {
        ItemPricingEngineImpl itemPricing = (ItemPricingEngineImpl)getItemPricingEngine();
        ItemPricingCalculator[] pricingCalculators = itemPricing.getPreCalculators();
      
        //If any calculator is an instance of atg.commerce.pricing.priceLists.ItemPriceCalculator then we are using price lists
        for(int index = 0; index < pricingCalculators.length; index++) {
          if(pricingCalculators[index] instanceof atg.commerce.pricing.priceLists.ItemPriceCalculator) {
            mUsingPriceLists = true;
            break;
          }
        }
      }
    }
  }

  /**
   * Returns the currency code for the given locale
   * @see java.text.DecimalFormatSymbols#getInternationalCurrencySymbol
   */
  public static String getInternationalCurrencySymbol(String pLocale) {
    Locale locale = RequestLocale.getCachedLocale(pLocale);
    return getInternationalCurrencySymbol(locale);
  }

  /**
   * Returns the currency code for the given locale
   * @see java.text.DecimalFormatSymbols#getInternationalCurrencySymbol
   */
  public static String getInternationalCurrencySymbol(Locale pLocale) {
    return getDecimalFormatSymbols( pLocale ).getInternationalCurrencySymbol();
  }

  /**
   * Returns the currency symbol for the given locale
   * @see java.text.DecimalFormatSymbols#getCurrencySymbol
   */
  public static String getCurrencySymbol(String pLocale) {
    Locale locale = RequestLocale.getCachedLocale(pLocale);
    return getCurrencySymbol(locale);
  }

  /**
   * Returns the currency symbol for the given locale
   * @see java.text.DecimalFormatSymbols#getCurrencySymbol
   */
  public static String getCurrencySymbol(Locale pLocale) {
    return getDecimalFormatSymbols( pLocale ).getCurrencySymbol();
  }

  /**
   * Returns the DecimalFormatSymbols object for the given locale
   *
   * @see java.text.DecimalFormatSymbols
   */
  public static DecimalFormatSymbols getDecimalFormatSymbols( String pLocale )
  {
    return getDecimalFormatSymbols( RequestLocale.getCachedLocale(pLocale) );
  }

  /**
   * Returns the DecimalFormatSymbols object for the given locale
   *
   * @see java.text.DecimalFormatSymbols
   */
  public static DecimalFormatSymbols getDecimalFormatSymbols( Locale pLocale )
  {
    String perfName = "getDecimalFormatSymbols";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {
      DecimalFormatSymbols symbol = (DecimalFormatSymbols)sDecimalFormatSymbols.get(pLocale);
      if (symbol == null) {
        symbol = new DecimalFormatSymbols(pLocale);
        sDecimalFormatSymbols.put(pLocale, symbol);
      }
      return symbol;
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        // can't log in a static method?
      }
    }
  }

  /**
   * This method will create a PriceChanged event and send it.  This
   * implementation only supports changes to the subtotal of the
   * order.  This means <code>pRepricedObject</code> must be
   * <code>pOrder</code>.  If other price change events are needed,
   * this method should be extended.  For example, if you want to
   * create a ShippingPriceChangedEvent, you should extend this
   * method to look for a ShippingGroup as the
   * <code>pRepricedObject</code> You will probably want the
   * <code>type</code> of the PriceChange message to reflect the
   * kind of price change.
   *
   * @param pOrder The order that was repriced
   * @param pProfile The owner of the order
   * @param pOldPrice The previous price of the order
   **/
  public PriceChanged createPriceChangedEvent(Order pOrder, RepositoryItem pProfile,
      CommerceIdentifier pRepricedObject, AmountInfo pOldPrice)
  throws PricingException
  {
    if((pRepricedObject != pOrder) &&
        (pRepricedObject != null)){
      throw new PricingException("Only price change events for the current order are supported.");
    }

    PriceChanged message = new PriceChanged();
    message.setOrder(pOrder);
    message.setProfile(pProfile);
    message.setRepricedObject(pRepricedObject);
    message.setOldPrice(pOldPrice);
    AmountInfo newPrice = null;
    if(pRepricedObject instanceof Order)
      newPrice = ((Order) pRepricedObject).getPriceInfo();
    message.setNewPrice(pOrder.getPriceInfo());

    return message;
  }

  /**
   * This method will send the given PriceChanged event on the
   * <code>scenarioEventPort</code> port.
   *
   * @param pMessage The scenario event to send
   **/
  public void sendPriceChangedEvent(PriceChanged pMessage)
  {
    try {
      if((pMessage.getProfile() == null) &&
          !isSendEventsWithNoProfile()) {
        if(isLoggingInfo()) {
          logInfo("This message has a null profile.  Do not send.\n" + pMessage.toString());
        }
        return;
      }
      else {
        pMessage.setId(getNextMessageId());

        if(isLoggingDebug())
          logDebug(pMessage.toString());

        if(isLoggingDebug())
          logDebug("Sending..... " + pMessage);
        sendObjectMessage(pMessage, pMessage.getType(), getScenarioEventPort());
      }
    } catch(JMSException j) {
      if(isLoggingError())
        logError("Could not send message: " + pMessage.getType(), j);
    }

  }

  /**
   * Returns the next unique Id for commerce messages.
   **/
  public String getNextMessageId()
  {
    IdGenerator idGen = getMessageIdGenerator();
    String space = getMessageIdSpaceName();
    if (idGen == null)
      return null;

    // generate an id in our id space and return it
    try
    {
      return idGen.generateStringId(space);
    }
    catch (IdGeneratorException ie)
    {
      return null;
    }
  }

  /**
   * Creates a temporary commerceItem object for pricing
   *
   * @param pCatalogRefId the id of the sku 
   * @param pProductId the id of the product
   * @param pQuantity the quantity
   * @return the temporary commerceItem
   */
  public CommerceItem createPricingCommerceItem(String pCatalogRefId, String pProductId, long pQuantity)
  throws CommerceException
  {

    if (isLoggingDebug())
      logDebug("creating CommerceItem: pCatalogRefId=" + pCatalogRefId + 
          "; pProductId=" + pProductId + "; pQuantity=" + pQuantity);

    PricingCommerceItem item = (PricingCommerceItem)(DictionaryThread.getObject(mCommerceItemKey));
    if (item == null) {
      item = new PricingCommerceItem();
    }
    else
      item.clear();

    item.setCatalogRefId(pCatalogRefId);
    item.setQuantity(pQuantity);
    try {
      item.setPriceInfo((ItemPriceInfo)getOrderTools().getDefaultItemPriceInfoClass().newInstance());
    } catch (IllegalAccessException e) {
      throw new CommerceException(e);
    }
    catch (InstantiationException e) {
      throw new CommerceException(e);
    } // end of try-catch

    AuxiliaryData aux = item.getAuxiliaryData();

    // Get the catalogRef and productRef objects 
    RepositoryItem catalogRef = null;
    RepositoryItem productRef = null;
    try {
      if (pCatalogRefId != null)
        catalogRef = getCatalogTools().findSKU(pCatalogRefId);
      if (pProductId != null)
        productRef = getCatalogTools().findProduct(pProductId);
    }
    catch(RepositoryException re) {
      throw new CommerceException(re);
    }

    aux.setCatalogRef(catalogRef);
    aux.setProductId(pProductId);
    aux.setProductRef(productRef);

    return item;
  }

  /**
   * Gets the profile repository item with the given id
   *
   * @param pProfileId the id of the profile to retrieve
   * @return the profie repository item
   * @exception RepositoryException if there was an error while retrieving the profile
   */
  public RepositoryItem getProfile(String pProfileId) throws RepositoryException
  {
    String profileType =  getProfileItemType();

    if (isLoggingDebug())
      logDebug("Searching for profile with id=" + pProfileId + "; type=" + profileType);

    RepositoryItem profile = null;
    if (pProfileId != null) {
      profile = getProfileRepository().getItem(pProfileId,profileType);
      if (isLoggingDebug())
        logDebug("Profile found: " + profile + " from id=" + pProfileId + "; type=" + profileType);
    }

    return profile;
  }

  /**
   * Computes the order total, including each item, all shipping groups and taxes. This
   * method refetches the current pricing models for the user from each pricing engine.
   * The first elements priced are the items, then shipping, then order (for sub total) and
   * finally the taxes. After each of those elements are priced, the <code>amount</code>
   * of the OrderPriceInfo for the order is updated to include the total shipping and taxes.
   * This method will use the default locale and fetches the user profile directly from
   * the order.
   * This method will regenerate order ranges
   * <code>PriceChanged</code> event will be thrown
   *
   * @see #createPriceChangedEvent
   *
   * @param pOrder the order to price
   * @return the complete order total
   * @exception PricingException if there was an error while computing the pricing information
   */
  public OrderPriceInfo priceOrderTotal(Order pOrder) throws PricingException
  {
    return priceOrderTotal(pOrder, null);
  }

  /**
   * Computes the order total, including each item, all shipping groups and taxes. This
   * method refetches the current pricing models for the user from each pricing engine.
   * The first elements priced are the items, then shipping, then order (for sub total) and
   * finally the taxes. After each of those elements are priced, the <code>amount</code>
   * of the OrderPriceInfo for the order is updated to include the total shipping and taxes.
   * This method will use the locale given. If the given locale is null, it will use the
   * default locale if useDefaultLocaleIfNotSpecified is true.  Otherwise, it will call
   * ServletUtil to determine the user's locale.  This method fetches the user profile 
   * directly from the order.
   * This method will regenerate order ranges
   * <code>PriceChanged</code> event will be thrown
   *
   * @see #createPriceChangedEvent
   *
   * @param pOrder the order to price
   * @param pLocale the locale to consider when pricing
   * @return the complete order total
   * @exception PricingException if there was an error while computing the pricing information
   */
  public OrderPriceInfo priceOrderTotal(Order pOrder, Locale pLocale) throws PricingException
  {
    String perfName = "priceOrderTotal";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {
      String profileId = pOrder.getProfileId();
      RepositoryItem profile = null;
      try {
        profile = getProfile(profileId);
      } catch (RepositoryException re) {
        try {
          if(!perfCancelled) {
            PerformanceMonitor.cancelOperation(PERFORM_MONITOR_NAME, perfName);
            perfCancelled = true;
          }
        }
        catch(PerfStackMismatchException psm) {
          if(isLoggingWarning())
            logWarning(psm);
        }

        throw new PricingException(re);
      }

      Locale locale = getLocale(pLocale);
      return priceOrderTotal(pOrder,locale,profile,null);
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally

  }
  
  public Locale getLocale(Locale pLocale) {
    Locale locale = pLocale;
    if (locale == null) {
      if (isUseDefaultLocaleIfNotSpecified())
        locale = getDefaultLocale();
      else locale = ServletUtil.getUserLocale();
    }
    
    return locale;
  }

  /**
   * Computes the order total, including each item, all shipping groups and taxes. This
   * method refetches the current pricing models for the user from each pricing engine.
   * The first elements priced are the items, then shipping, then order (for sub total) and
   * finally the taxes. After each of those elements are priced, the <code>amount</code>
   * of the OrderPriceInfo for the order is updated to include the total shipping and taxes.
   * This method will regenerate order ranges
   * <code>PriceChanged</code> event will be thrown
   *
   * @see #createPriceChangedEvent
   *
   * @param pOrder the order to price
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @return the complete order total
   * @exception PricingException if there was an error while computing the pricing information
   */
  public OrderPriceInfo priceOrderTotal(Order pOrder,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "priceOrderTotal2";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {   
      Collection itemPricingModels = getItemPricingEngine().getPricingModels(pProfile);
      Collection shippingPricingModels = getShippingPricingEngine().getPricingModels(pProfile);
      Collection orderPricingModels = getOrderPricingEngine().getPricingModels(pProfile);
      Collection taxPricingModels =  getTaxPricingEngine().getPricingModels(pProfile);
      return priceOrderTotal(pOrder,
          itemPricingModels, shippingPricingModels, orderPricingModels, taxPricingModels,
          pLocale, pProfile, pExtraParameters);
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally
  }

  /**
   * Computes the order total, including each item, all shipping groups and taxes. This method
   * extracts the promotions from the session-scoped PricingModelHolder parameter.
   * The first elements priced are the items, then shipping, then order (for sub total) and
   * finally the taxes. After each of those elements are priced, the <code>amount</code>
   * of the OrderPriceInfo for the order is updated to include the total shipping and taxes.
   * This method will regenerate order ranges
   * <code>PriceChanged</code> event will be thrown
   *
   * @see #createPriceChangedEvent
   *
   * @param pOrder the order to price
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pPricingModels the PricingModelHolder is an object which contains all the
   * pricing models associated with a user (i.e. item, shipping, order and tax).
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @return the complete order total
   * @exception PricingException if there was an error while computing the pricing information
   */
  public OrderPriceInfo priceOrderTotal(Order pOrder,
      PricingModelHolder pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "priceOrderTotal3";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {

      Collection itemPricingModels = null;
      Collection shippingPricingModels = null;
      Collection orderPricingModels = null;
      Collection taxPricingModels =  null;

      if (pPricingModels != null) {
        itemPricingModels = pPricingModels.getItemPricingModels();
        shippingPricingModels = pPricingModels.getShippingPricingModels();
        orderPricingModels = pPricingModels.getOrderPricingModels();
        taxPricingModels =  pPricingModels.getTaxPricingModels();
      }

      return priceOrderTotal(pOrder,
          itemPricingModels, shippingPricingModels, orderPricingModels, taxPricingModels,
          pLocale, pProfile, pExtraParameters);

    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally

  }

  /**
   * Computes the order total, including each item, all shipping groups and taxes. This
   * method is supplied with the pricing models that should be used for each pricing engine.
   * The first elements priced are the items, then shipping, then order (for sub total) and
   * finally the taxes. After each of those elements are priced, the <code>amount</code>
   * of the OrderPriceInfo for the order is updated to include the total shipping and taxes.
   * This method will regenerate order ranges
   * <code>PriceChanged</code> event will be thrown
   *
   * @see #createPriceChangedEvent
   *
   * @param pOrder the order to price
   * @param pItemPricingModels the pricing models that affect items
   * @param pShippingPricingModels the pricing models that affect shipping
   * @param pOrderPricingModels the pricing models that affect the order (e.g. sub total)
   * @param pTaxPricingModels the pricing models that affect taxes
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @return the complete order total
   * @exception PricingException if there was an error while computing the pricing information
   */
  public OrderPriceInfo priceOrderTotal(Order pOrder,
      Collection pItemPricingModels,
      Collection pShippingPricingModels,
      Collection pOrderPricingModels,
      Collection pTaxPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "priceOrderTotal4";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean cancelPerfMonitor = false;

    if (pOrder == null)
      return null;

    synchronized (pOrder) {
      try {
        double oldPrice = 0.0;
        OrderPriceInfo oldInfo = null;
        // remember the old price just in case we need to send a PriceChanged event
        if(isGeneratePriceChangedEvents()) {
          if(pOrder.getPriceInfo() != null) {
            oldInfo = pOrder.getPriceInfo();
            // Amount is the subtotal
            oldPrice = oldInfo.getAmount();
          }
        }

        if (isLoggingDebug())
          logDebug("priceOrderTotal: pOrder=" + pOrder +
              "; pItemPricingModels=" + pItemPricingModels +
              "; pShippingPricingModels=" + pShippingPricingModels +
              "; pOrderPricingModels=" + pOrderPricingModels +
              "; pTaxPricingModels=" + pTaxPricingModels +
              "; pLocale=" + pLocale +
              "; pProfile=" + pProfile +
              "; pExtraParameters=" + pExtraParameters);

        // make sure the ranges are in place
        getCommerceItemManager().generateRangesForOrder(pOrder);
        
        Map params = pExtraParameters;
        if(params == null)
          params = new HashMap();
        
        priceItemsForOrderTotal(pOrder, pItemPricingModels, pLocale, pProfile, params, false);
        priceOrderForOrderTotal(pOrder, pOrderPricingModels, pLocale, pProfile, params, false);
        double shippingTotal = priceShippingForOrderTotal(pOrder, pShippingPricingModels, pLocale,
            pProfile, params, false);
        double taxTotal = priceTaxForOrderTotal(pOrder,pTaxPricingModels, pLocale, pProfile, params, false);
        OrderPriceInfo info = pOrder.getPriceInfo();
        if (info != null) {
          info.setShipping(shippingTotal);
          info.setTax(taxTotal);
          if (isLoggingDebug())
            logDebug("priceOrderTotal: shipping=" + shippingTotal +
                "; taxTotal=" + taxTotal +
                "; order amount=" + info.getAmount());

          // do we need to send a PriceChanged event?
          if(isGeneratePriceChangedEvents()) {
            double newPrice = info.getAmount();
            if(isLoggingDebug())
              logDebug("Checking: " + newPrice + " =? " + oldPrice);

            if(newPrice != oldPrice) {
              PriceChanged event = createPriceChangedEvent(pOrder, pProfile, pOrder, oldInfo);
              sendPriceChangedEvent(event);
            }
          }

          return info;
        }
        return null;
      }
      catch (PricingException pe) {
        // Rethrow any pricing exception generated by priceItems or priceOrder calls
        cancelPerfMonitor = true;
        throw pe;
      }
      catch (CommerceException ce) {
        // Catch any commerce exception generated by generateRangesForOrder
        cancelPerfMonitor = true;
        throw new PricingException(ce);
      }
      finally {
        try {
          if(cancelPerfMonitor)
            PerformanceMonitor.cancelOperation(PERFORM_MONITOR_NAME, perfName);
          else
            PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
        } catch (PerfStackMismatchException e) {
          if (isLoggingWarning()) {
            logWarning(e);
          }
        }
      }
    }
  }

  /**
   * Computes the order subtotal, including each item, but not shipping and taxes. This
   * method refetches the current pricing models for the user from each pricing engine.
   * This method will regenerate order ranges if necessary
   * <code>PriceChanged</code> event will be thrown
   *
   * @see #createPriceChangedEvent
   *
   * @param pOrder the order to price
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @return the complete order subtotal
   * @exception PricingException if there was an error while computing the pricing information
   */
  public OrderPriceInfo priceOrderSubtotal(Order pOrder,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "priceOrderSubtotal";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {

      Collection itemPricingModels = getItemPricingEngine().getPricingModels(pProfile);
      Collection orderPricingModels = getOrderPricingEngine().getPricingModels(pProfile);
      return priceOrderSubtotal(pOrder, itemPricingModels, orderPricingModels,
          pLocale, pProfile, pExtraParameters);
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally

  }

  /**
   * Computes the order subtotal, including each item, but not shipping and taxes. This method
   * extracts the promotions from the session-scoped PricingModelHolder parameter.
   * This method will regenerate order ranges if necessary
   * <code>PriceChanged</code> event will be thrown
   *
   * @see #createPriceChangedEvent
   *
   * @param pOrder the order to price
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pPricingModels the PricingModelHolder is an object which contains all the
   * pricing models associated with a user (i.e. item, shipping, order and tax).
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @return the complete order subtotal
   * @exception PricingException if there was an error while computing the pricing information
   */
  public OrderPriceInfo priceOrderSubtotal(Order pOrder,
      PricingModelHolder pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "priceOrderSubtotal2";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {

      Collection itemPricingModels = null;
      Collection orderPricingModels = null;

      if (pPricingModels != null) {
        itemPricingModels = pPricingModels.getItemPricingModels();
        orderPricingModels = pPricingModels.getOrderPricingModels();
      }

      return priceOrderSubtotal(pOrder, itemPricingModels, orderPricingModels,
          pLocale, pProfile, pExtraParameters);

    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally

  }

  /**
   * Computes the order subtotal, including each item, but not shipping and taxes.
   * This method will regenerate order ranges if necessary
   * If the subtotal changed and <code>generatePriceChangedEvents</code> then a
   * <code>PriceChanged</code> event will be thrown
   *
   * @see #createPriceChangedEvent
   *
   * @param pOrder the order to price
   * @param pItemPricingModels the pricing models that affect items
   * @param pOrderPricingModels the pricing models that affect the order (e.g. sub total)
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @return the complete order subtotal
   * @exception PricingException if there was an error while computing the pricing information
   */
  public OrderPriceInfo priceOrderSubtotal(Order pOrder,
      Collection pItemPricingModels,
      Collection pOrderPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "priceOrderSubtotal3";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean cancelPerfMonitor = false;

    if (pOrder == null)
      return null;

    synchronized (pOrder) {
      try {
        double oldPrice = 0.0;
        OrderPriceInfo oldInfo = null;
        // remember the old price just in case we need to send a PriceChanged event
        if(isGeneratePriceChangedEvents()) {
          if(pOrder.getPriceInfo() != null) {
            oldInfo = pOrder.getPriceInfo();
            // Amount is the subtotal
            oldPrice = oldInfo.getAmount();
          }
        }

        // make sure the ranges are in place
        getCommerceItemManager().generateRangesForOrder(pOrder);
        Map params = pExtraParameters;
        if(params == null)
          params = new HashMap();
        priceItemsForOrderTotal(pOrder, pItemPricingModels, pLocale, pProfile, params, false);
        priceOrderForOrderTotal(pOrder, pOrderPricingModels, pLocale, pProfile, params, false);
        OrderPriceInfo info = pOrder.getPriceInfo();
        if (info != null) {

          // do we need to send a PriceChanged event?
          if(isGeneratePriceChangedEvents()) {
            double newPrice = info.getAmount();
            if(isLoggingDebug())
              logDebug("Checking: " + newPrice + " =? " + oldPrice);

            if(newPrice != oldPrice) {
              PriceChanged event = createPriceChangedEvent(pOrder, pProfile, pOrder, oldInfo);
              sendPriceChangedEvent(event);
            }
          }

          return info;
        }
        return null;
      }
      catch (PricingException pe) {
        // Rethrow any pricing exception generated by priceItems or priceOrder calls
        cancelPerfMonitor = true;
        throw pe;
      }
      catch (CommerceException ce) {
        // Catch any commerce exception generated by generateRangesForOrder
        cancelPerfMonitor = true;
        throw new PricingException(ce);
      }
      finally {
        try {
          if(cancelPerfMonitor)
            PerformanceMonitor.cancelOperation(PERFORM_MONITOR_NAME, perfName);
          else
            PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
        } catch (PerfStackMismatchException e) {
          if (isLoggingWarning()) {
            logWarning(e);
          }
        }
      }
    }
  }

  /**
   * Computes the order subtotal, including each item, and all shipping costs, but not taxes. This
   * method refetches the current pricing models for the user from each pricing engine.
   * This method will regenerate order ranges if necessary
   * @param pOrder the order to price
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @return the complete order subtotal
   * @exception PricingException if there was an error while computing the pricing information
   */
  public OrderPriceInfo priceOrderSubtotalShipping(Order pOrder,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "priceOrderSubtotalShipping";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {

      Collection itemPricingModels = getItemPricingEngine().getPricingModels(pProfile);
      Collection shippingPricingModels = getShippingPricingEngine().getPricingModels(pProfile);
      Collection orderPricingModels = getOrderPricingEngine().getPricingModels(pProfile);
      return priceOrderSubtotalShipping(pOrder, itemPricingModels, shippingPricingModels, orderPricingModels,
          pLocale, pProfile, pExtraParameters);
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally

  }

  /**
   * Computes the order subtotal, including each item, and all shipping costs, but not taxes. This method
   * extracts the promotions from the session-scoped PricingModelHolder parameter.
   * This method will regenerate order ranges if necessary
   * @param pOrder the order to price
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pPricingModels the PricingModelHolder is an object which contains all the
   * pricing models associated with a user (i.e. item, shipping, order and tax).
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @return the complete order subtotal
   * @exception PricingException if there was an error while computing the pricing information
   */
  public OrderPriceInfo priceOrderSubtotalShipping(Order pOrder,
      PricingModelHolder pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "priceOrderSubtotalShipping2";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {

      Collection itemPricingModels = null;
      Collection shippingPricingModels = null;
      Collection orderPricingModels = null;

      if (pPricingModels != null) {
        itemPricingModels = pPricingModels.getItemPricingModels();
        shippingPricingModels = pPricingModels.getShippingPricingModels();
        orderPricingModels = pPricingModels.getOrderPricingModels();
      }

      return priceOrderSubtotalShipping(pOrder, itemPricingModels, shippingPricingModels, orderPricingModels,
          pLocale, pProfile, pExtraParameters);

    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally

  }

  /**
   * Computes the order subtotal, including each item, and all shipping costs, but not taxes.
   * This method will regenerate order ranges if necessary
   * @param pOrder the order to price
   * @param pItemPricingModels the pricing models that affect items
   * @param pShippingPricingModels the pricing models that affect shipping
   * @param pOrderPricingModels the pricing models that affect the order (e.g. sub total)
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @return the complete order subtotal
   * @exception PricingException if there was an error while computing the pricing information
   */
  public OrderPriceInfo priceOrderSubtotalShipping(Order pOrder,
      Collection pItemPricingModels,
      Collection pShippingPricingModels,
      Collection pOrderPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "priceOrderSubtotalShipping3";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean cancelPerfMonitor = false;

    if (pOrder == null)
      return null;

    synchronized (pOrder) {

      try {
        // make sure the ranges are in place
        getCommerceItemManager().generateRangesForOrder(pOrder);
        
        Map params = pExtraParameters;
        if(params == null)
          params = new HashMap();
        
        priceItemsForOrderTotal(pOrder, pItemPricingModels, pLocale, pProfile, params, false);
        priceOrderForOrderTotal(pOrder, pOrderPricingModels, pLocale, pProfile, params, false);
        double shippingTotal = priceShippingForOrderTotal(pOrder, pShippingPricingModels, pLocale,
            pProfile, params, false);
        OrderPriceInfo info = pOrder.getPriceInfo();
        if (info != null) {
          info.setShipping(shippingTotal);
          return info;
        }
        return null;
      }
      catch (PricingException pe) {
        // Rethrow any pricing exception generated by priceItems or priceOrder calls
        cancelPerfMonitor = true;
        throw pe;
      }
      catch (CommerceException ce) {
        // Catch any commerce exception generated by generateRangesForOrder
        cancelPerfMonitor = true;
        throw new PricingException(ce);
      }
      finally {
        try {
          if(cancelPerfMonitor)
            PerformanceMonitor.cancelOperation(PERFORM_MONITOR_NAME, perfName);
          else
            PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
        } catch (PerfStackMismatchException e) {
          if (isLoggingWarning()) {
            logWarning(e);
          }
        }
      }// end finally
    }
  }

  /**
   * Computes the order subtotal, including each item, and all taxes, but not shipping. This
   * method refetches the current pricing models for the user from each pricing engine.
   * This method will regenerate order ranges if necessary
   * @param pOrder the order to price
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @return the complete order subtotal
   * @exception PricingException if there was an error while computing the pricing information
   */
  public OrderPriceInfo priceOrderSubtotalTax(Order pOrder,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "priceOrderSubtotalTax";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {

      Collection itemPricingModels = getItemPricingEngine().getPricingModels(pProfile);
      Collection orderPricingModels = getOrderPricingEngine().getPricingModels(pProfile);
      Collection taxPricingModels =  getTaxPricingEngine().getPricingModels(pProfile);
      return priceOrderSubtotalTax(pOrder, itemPricingModels, orderPricingModels, taxPricingModels,
          pLocale, pProfile, pExtraParameters);
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally

  }

  /**
   * Computes the order subtotal, including each item, and all taxes, but not shipping. This method
   * extracts the promotions from the session-scoped PricingModelHolder parameter.
   * This method will regenerate order ranges if necessary
   * @param pOrder the order to price
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pPricingModels the PricingModelHolder is an object which contains all the
   * pricing models associated with a user (i.e. item, shipping, order and tax).
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @return the complete order subtotal
   * @exception PricingException if there was an error while computing the pricing information
   */
  public OrderPriceInfo priceOrderSubtotalTax(Order pOrder,
      PricingModelHolder pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "priceOrderSubtotalTax2";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {

      Collection itemPricingModels = null;
      Collection orderPricingModels = null;
      Collection taxPricingModels =  null;

      if (pPricingModels != null) {
        itemPricingModels = pPricingModels.getItemPricingModels();
        orderPricingModels = pPricingModels.getOrderPricingModels();
        taxPricingModels =  pPricingModels.getTaxPricingModels();
      }

      return priceOrderSubtotalTax(pOrder, itemPricingModels, orderPricingModels, taxPricingModels,
          pLocale, pProfile, pExtraParameters);

    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally

  }

  /**
   * Computes the order subtotal, including each item, and all taxes, but not shipping.
   * @param pOrder the order to price
   * @param pItemPricingModels the pricing models that affect items
   * @param pOrderPricingModels the pricing models that affect the order (e.g. sub total)
   * @param pTaxPricingModels the pricing models that affect taxes
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @return the complete order subtotal
   * @exception PricingException if there was an error while computing the pricing information
   */
  public OrderPriceInfo priceOrderSubtotalTax(Order pOrder,
      Collection pItemPricingModels,
      Collection pOrderPricingModels,
      Collection pTaxPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "priceOrderSubtotalTax3";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean cancelPerfMonitor = false;

    if (pOrder == null)
      return null;

    synchronized (pOrder) {
      try {

        getCommerceItemManager().generateRangesForOrder(pOrder);

        Map params = pExtraParameters;
        if(params == null)
          params = new HashMap();
        priceItemsForOrderTotal(pOrder, pItemPricingModels, pLocale, pProfile, params, false);
        priceOrderForOrderTotal(pOrder, pOrderPricingModels, pLocale, pProfile, params, false);
        double taxTotal = priceTaxForOrderTotal(pOrder,pTaxPricingModels, pLocale, pProfile, params, false);
        OrderPriceInfo info = pOrder.getPriceInfo();
        if (info != null) {
          info.setTax(taxTotal);
          return info;
        }
        return null;
      }
      catch (PricingException pe) {
        // Rethrow any pricing exception generated by priceItems or priceOrders calls
        cancelPerfMonitor = true;
        throw pe;
      }
      catch (CommerceException ce) {
        // Catch any commerce exception generated by generateRangesForOrder
        cancelPerfMonitor = true;
        throw new PricingException(ce);
      }
      finally {
        try {
          if (cancelPerfMonitor)
            PerformanceMonitor.cancelOperation(PERFORM_MONITOR_NAME, perfName);
          else
            PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
        } catch (PerfStackMismatchException e) {
          if (isLoggingWarning()) {
            logWarning(e);
          }
        }
      }// end finally
    }
  }

  /**
   * Price the single item, and set it's priceInfo to the result. The pricing models
   * are gathered from the Item Pricing Engine using the profile.
   * This method will regenerate order ranges if necessary
   * @param pCommerceItems the items to price
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @exception PricingException if there was an error while computing the pricing information
   */
  public void priceItem(CommerceItem pCommerceItem,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    Collection itemPricingModels = getItemPricingEngine().getPricingModels(pProfile);
    priceItem(pCommerceItem, itemPricingModels, pLocale, pProfile, pExtraParameters);
  }

  /**
   * Price the single item, and set it's priceInfo to the result. The pricing models
   * are taken from the supplied PricingModelHolder.
   * This method will regenerate order ranges if necessary
   * @param pCommerceItems the items to price
   * @param pPricingModels the PricingModelHolder is an object which contains all the
   * pricing models associated with a user (i.e. item, shipping, order and tax).
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @exception PricingException if there was an error while computing the pricing information
   */
  public void priceItem(CommerceItem pCommerceItem,
      PricingModelHolder pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "priceItem";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {
      Collection itemPricingModels = null;
      if (pPricingModels != null) {
        itemPricingModels = pPricingModels.getItemPricingModels();
      }
      priceItem(pCommerceItem, itemPricingModels, pLocale, pProfile, pExtraParameters);
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally
  }

  /**
   * Price all the single item, and set it's priceInfo to the result.
   * This method will regenerate item ranges if necessary
   * @param pCommerceItems the items to price
   * @param pPricingModels the pricing models used in this pricing
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @exception PricingException if there was an error while computing the pricing information
   **/
  public void priceItem(CommerceItem pCommerceItem,
      Collection pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    priceItem(pCommerceItem, pPricingModels, pLocale, pProfile, pExtraParameters, true);
  }

  /**
   * Price all the single item, and set it's priceInfo to the result.
   * @param pCommerceItems the items to price
   * @param pPricingModels the pricing models used in this pricing
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @param pGenerateItemRanges If this is true, <code>CommerceItemManager.generateRangeForItem</code>
   *                            is called for each item
   * @exception PricingException if there was an error while computing the pricing information
   * @see atg.commerce.order.CommerceItemManager#generateRangeForItem
   */
  protected void priceItem(CommerceItem pCommerceItem,
      Collection pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters,
      boolean pGenerateItemRanges)
  throws PricingException
  {
    String perfName = "priceItem2";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {
      if (pCommerceItem != null) {
        // make sure the ranges are in place
        if(pGenerateItemRanges) {
          try {
            getCommerceItemManager().generateRangeForItem(pCommerceItem);
          }
          catch(CommerceException ce) {
            try {
              if(!perfCancelled) {
                PerformanceMonitor.cancelOperation(PERFORM_MONITOR_NAME, perfName);
                perfCancelled = true;
              }
            }
            catch(PerfStackMismatchException psm) {
              if(isLoggingWarning())
                logWarning(psm);
            }

            throw new PricingException(ce);
          }
        }
        Map params = pExtraParameters;
        if(params == null)
          params = new HashMap();

        ItemPriceInfo info = getItemPricingEngine().priceItem(pCommerceItem,
            pPricingModels,
            pLocale,
            pProfile,
            params);
        pCommerceItem.setPriceInfo(info);
      }
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally
  }

  /**
   * Price all the items, and set each of their priceInfo to the result. The pricing models
   * are gathered from the Item Pricing Engine using the profile.
   * This method will regenerate item ranges if necessary
   * @param pCommerceItems the items to price
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @exception PricingException if there was an error while computing the pricing information
   */
  public void priceEachItem(List pCommerceItems,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    Collection itemPricingModels = getItemPricingEngine().getPricingModels(pProfile);
    priceEachItem(pCommerceItems, itemPricingModels, pLocale, pProfile, pExtraParameters);
  }

  /**
   * Price all the items, and set each of their priceInfo to the result. The pricing models
   * are taken from the supplied PricingModelHolder.
   * This method will regenerate item ranges if necessary
   * @param pCommerceItems the items to price
   * @param pPricingModels the PricingModelHolder is an object which contains all the
   * pricing models associated with a user (i.e. item, shipping, order and tax).
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @exception PricingException if there was an error while computing the pricing information
   */
  public void priceEachItem(List pCommerceItems,
      PricingModelHolder pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "priceEachItem";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {
      Collection itemPricingModels = null;
      if (pPricingModels != null) {
        itemPricingModels = pPricingModels.getItemPricingModels();
      }
      priceEachItem(pCommerceItems, itemPricingModels, pLocale, pProfile, pExtraParameters);
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally
  }

  /**
   * Price all the items, and set each of their priceInfo to the result.
   * This method will regenerate item ranges if necessary
   * @param pCommerceItems the items to price
   * @param pPricingModels the pricing models used in this pricing
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @exception PricingException if there was an error while computing the pricing information
   */
  public void priceEachItem(List pCommerceItems,
      Collection pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    priceEachItem(pCommerceItems, pPricingModels, pLocale, pProfile, pExtraParameters, true);
  }

  /**
   * Price all the items, and set each of their priceInfo to the result.
   * @param pCommerceItems the items to price
   * @param pPricingModels the pricing models used in this pricing
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @param pGenerateItemRanges If this is true, <code>CommerceItemManager.generateRangeForItem</code>
   *                            is called for each item
   * @exception PricingException if there was an error while computing the pricing information
   * @see atg.commerce.order.CommerceItemManager#generateRangeForItem
   */
  protected void priceEachItem(List pCommerceItems,
      Collection pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters,
      boolean pGenerateItemRanges)
  throws PricingException
  {
    String perfName = "priceEachItem2";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {
      if (pCommerceItems != null) {
        // make sure the ranges are in place
        if(pGenerateItemRanges) {
          try {
            for(int i=0; i<pCommerceItems.size(); i++) {
              CommerceItem item = (CommerceItem) pCommerceItems.get(i);
              getCommerceItemManager().generateRangeForItem(item);
            }
          }
          catch(CommerceException ce) {
            try {
              if(!perfCancelled) {
                PerformanceMonitor.cancelOperation(PERFORM_MONITOR_NAME, perfName);
                perfCancelled = true;
              }
            }
            catch(PerfStackMismatchException psm) {
              if(isLoggingWarning())
                logWarning(psm);
            }

            throw new PricingException(ce);
          }
        }

        Map params = pExtraParameters;
        if(params == null)
          params = new HashMap();
        List infos = getItemPricingEngine().priceEachItem(pCommerceItems,
            pPricingModels,
            pLocale,
            pProfile,
            params);
        if (infos != null) {
          int size = pCommerceItems.size();
          if (infos.size() != size)
            throw new PricingException(Constants.ITEM_PRICE_MISMATCH);
          for (int c=0; c<size; c++) {
            CommerceItem item = (CommerceItem)pCommerceItems.get(c);
            ItemPriceInfo info = (ItemPriceInfo)infos.get(c);
            item.setPriceInfo(info);
          }
        }
      }
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally
  }

  /**
   * Price all the items, and set each of their priceInfo to the result.  The pricing models
   * are gathered from the Item Pricing Engine using the profile.
   * This method will regenerate order ranges if necessary
   * @return the total of all the items
   * @param pOrder the order to price
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @exception PricingException if there was an error while computing the pricing information
   */
  public double priceItemsForOrderTotal(Order pOrder,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    Collection itemPricingModels = getItemPricingEngine().getPricingModels(pProfile);
    return priceItemsForOrderTotal(pOrder, itemPricingModels, pLocale, pProfile, pExtraParameters);
  }

  /**
   * Price all the items, and set each of their priceInfo to the result.  The pricing models
   * are taken from the supplied PricingModelHolder.
   * This method will regenerate order ranges if necessary
   * @return the total of all the items
   * @param pOrder the order to price
   * @param pPricingModels the PricingModelHolder is an object which contains all the
   * pricing models associated with a user (i.e. item, shipping, order and tax).
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @exception PricingException if there was an error while computing the pricing information
   */
  public double priceItemsForOrderTotal(Order pOrder,
      PricingModelHolder pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "priceItemsForOrderTotal";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {
      Collection itemPricingModels = null;
      if (pPricingModels != null) {
        itemPricingModels = pPricingModels.getItemPricingModels();
      }
      return priceItemsForOrderTotal(pOrder, itemPricingModels, pLocale, pProfile, pExtraParameters);
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally
  }

  /**
   * Price all the items, and set each of their priceInfo to the result.
   * This method will regenerate order ranges if necessary
   * @return the total of all the items
   * @param pOrder the order to price
   * @param pPricingModels the pricing models used in this pricing
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @exception PricingException if there was an error while computing the pricing information
   */
  protected double priceItemsForOrderTotal(Order pOrder,
      Collection pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    return priceItemsForOrderTotal(pOrder, pPricingModels, pLocale, pProfile, pExtraParameters, true);
  }

  /**
   * Price all the items, and set each of their priceInfo to the result.
   * @return the total of all the items
   * @param pOrder the order to price
   * @param pPricingModels the pricing models used in this pricing
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @param pGenerateOrderRanges If this is true, <code>CommerceItemManager.generateRangesForOrder</code>
   * @exception PricingException if there was an error while computing the pricing information
   * @see atg.commerce.order.CommerceItemManager#generateRangesForOrder
   */
  protected double priceItemsForOrderTotal(Order pOrder,
      Collection pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters,
      boolean pGenerateOrderRanges)
  throws PricingException
  {
    String perfName = "priceItemsForOrderTotal2";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean cancelPerfMonitor = false;

    synchronized (pOrder) {
      try {
        // make sure the ranges are in place
        if(pGenerateOrderRanges)
          getCommerceItemManager().generateRangesForOrder(pOrder);

        double total = 0;
        List commerceItems = pOrder.getCommerceItems();

        Map params = pExtraParameters;
        if(params == null)
          params = new HashMap();
        List infos = getItemPricingEngine().priceItems(commerceItems,
            pPricingModels,
            pLocale,
            pProfile,
            pOrder,
            params);
        if (infos != null) {
          int size = commerceItems.size();
          if (infos.size() != size)
            throw new PricingException(Constants.ITEM_PRICE_MISMATCH);
          for (int c=0; c<size; c++) {
            CommerceItem item = (CommerceItem)commerceItems.get(c);
            ItemPriceInfo info = (ItemPriceInfo)infos.get(c);
            ItemPriceInfo oldPriceInfo = item.getPriceInfo();
            item.setPriceInfo(info);
            if (isSendPromotionClosenessMessages())
              compareQualifiers(oldPriceInfo, info, pOrder, pProfile);
            if (info != null)
              total += info.getAmount();
          }
        }
        return total;
      }
      catch (PricingException pe) {
        // Rethrow any pricing exception generated by priceItems
        cancelPerfMonitor = true;
        throw pe;
      }
      catch (CommerceException ce) {
        // Catch any commerce exception generated by getRangesForOrder
        cancelPerfMonitor = true;
        throw new PricingException(ce);
      }
      finally {
        try {
          if(cancelPerfMonitor)
            PerformanceMonitor.cancelOperation(PERFORM_MONITOR_NAME, perfName);
          else
            PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
        } catch (PerfStackMismatchException e) {
          if (isLoggingWarning()) {
            logWarning(e);
          }
        }
      }// end finally
    }
  }

  /**
   * Price each shipping group, and set their priceInfo's to the result. The pricing models
   * are gathered from the Shipping Pricing Engine using the profile.
   * This method will regenerate order ranges if necessary
   * @return the total of all the shipping
   * @param pOrder the order to price
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @exception PricingException if there was an error while computing the pricing information
   */
  public double priceShippingForOrderTotal(Order pOrder,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    Collection shippingPricingModels = getShippingPricingEngine().getPricingModels(pProfile);
    return priceShippingForOrderTotal(pOrder, shippingPricingModels, pLocale, pProfile, pExtraParameters);
  }

  /**
   * Price each shipping group, and set their priceInfo's to the result. The pricing models
   * are taken from the supplied PricingModelHolder.
   * This method will regenerate order ranges if necessary
   * @return the total of all the shipping
   * @param pOrder the order to price
   * @param pPricingModels the PricingModelHolder is an object which contains all the
   * pricing models associated with a user (i.e. item, shipping, order and tax).
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @exception PricingException if there was an error while computing the pricing information
   */
  public double priceShippingForOrderTotal(Order pOrder,
      PricingModelHolder pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "priceShippingForOrderTotal";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {
      Collection shippingPricingModels = null;
      if (pPricingModels != null) {
        shippingPricingModels = pPricingModels.getShippingPricingModels();
      }
      return priceShippingForOrderTotal(pOrder, shippingPricingModels, pLocale, pProfile, pExtraParameters);
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally
  }

  /**
   * Price each shipping group, and set their priceInfo's to the result
   * This method will regenerate order ranges if necessary
   * @return the total of all the shipping
   * @param pOrder the order to price
   * @param pPricingModels the pricing models used in this pricing
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @exception PricingException if there was an error while computing the pricing information
   */
  public double priceShippingForOrderTotal(Order pOrder,
      Collection pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    return priceShippingForOrderTotal(pOrder, pPricingModels, pLocale, pProfile, pExtraParameters, true);
  }

  /**
   * Price each shipping group, and set their priceInfo's to the result
   * @return the total of all the shipping
   * @param pOrder the order to price
   * @param pPricingModels the pricing models used in this pricing
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @param pGenerateOrderRanges If this is true, <code>CommerceItemManager.generateRangesForOrder</code>
   * @exception PricingException if there was an error while computing the pricing information
   * @see atg.commerce.order.CommerceItemManager#generateRangesForOrder
   */
  protected double priceShippingForOrderTotal(Order pOrder,
      Collection pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters,
      boolean pGenerateOrderRanges)
  throws PricingException
  {
    String perfName = "priceShippingForOrderTotal2";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean cancelPerfMonitor = false;

    synchronized (pOrder) {
      try {
        // make sure the ranges are in place
        if(pGenerateOrderRanges)
          getCommerceItemManager().generateRangesForOrder(pOrder);

        double total = 0;
        List shippingGroups = pOrder.getShippingGroups();
        if (shippingGroups != null) {
          /*
           * We keep the list of promotions so we know what has been used.
           * This is necessary since shipping groups all get priced
           * individually.  They should probably be priced collectively.
           * In the meantime, this list is stored in the extraparams, which
           * means this can't be null.
           */
          Map extras = pExtraParameters;
          if(extras == null)
            extras = new HashMap();

          for (int c=0; c<shippingGroups.size(); c++) {
            ShippingGroup shippingGroup = (ShippingGroup)shippingGroups.get(c);
            if (shippingGroup != null) {

              ShippingPriceInfo info = getShippingPricingEngine().priceShippingGroup(pOrder,
                  shippingGroup,
                  pPricingModels,
                  pLocale,
                  pProfile,
                  extras);
              ShippingPriceInfo oldPriceInfo = shippingGroup.getPriceInfo();
              shippingGroup.setPriceInfo(info);
              if (isSendPromotionClosenessMessages())
                compareQualifiers(oldPriceInfo, info, pOrder, pProfile);
              if (info != null)
                total += info.getAmount();
            }
          }
          if(pExtraParameters != null)
            pExtraParameters.remove("ATGSHIPPINGPROMOTIONSFORTHISCONTEXT123");
        }
        return total;
      }
      catch (PricingException pe) {
        // Rethrow any pricing exception generated by priceShippingGroup
        cancelPerfMonitor = true;
        throw pe;
      }
      catch (CommerceException ce) {
        // Catch commerce exceptions from getRangesForOrder
        cancelPerfMonitor = true;
        throw new PricingException(ce);
      }
      finally {
        try {
          if(cancelPerfMonitor)
            PerformanceMonitor.cancelOperation(PERFORM_MONITOR_NAME, perfName);
          else
            PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
        } catch (PerfStackMismatchException e) {
          if (isLoggingWarning()) {
            logWarning(e);
          }
        }
      }
    }
  }

  /**
   * Price the sub total and any order level discounts. The OrderPriceInfo of the Order
   * will contain the raw subtotal for all the items, and the amount will include any
   * order level discounts. The tax and shipping are not set. The pricing models
   * are gathered from the Order Pricing Engine using the profile.
   * This method will regenerate order ranges if necessary
   * @return the total of the order, minus shipping and taxes
   * @param pOrder the order to price
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @exception PricingException if there was an error while computing the pricing information
   */
  public double priceOrderForOrderTotal(Order pOrder,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    Collection orderPricingModels = getOrderPricingEngine().getPricingModels(pProfile);
    return priceOrderForOrderTotal(pOrder, orderPricingModels, pLocale, pProfile, pExtraParameters);
  }

  /**
   * Price the sub total and any order level discounts. The OrderPriceInfo of the Order
   * will contain the raw subtotal for all the items, and the amount will include any
   * order level discounts. The tax and shipping are not set. The pricing models
   * are taken from the supplied PricingModelHolder.
   * This method will regenerate order ranges if necessary
   * @return the total of the order, minus shipping and taxes
   * @param pOrder the order to price
   * @param pPricingModels the PricingModelHolder is an object which contains all the
   * pricing models associated with a user (i.e. item, shipping, order and tax).
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @exception PricingException if there was an error while computing the pricing information
   */
  public double priceOrderForOrderTotal(Order pOrder,
      PricingModelHolder pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "priceOrderForOrderTotal";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {
      Collection orderPricingModels = null;
      if (pPricingModels != null) {
        orderPricingModels = pPricingModels.getOrderPricingModels();
      }
      return priceOrderForOrderTotal(pOrder, orderPricingModels, pLocale, pProfile, pExtraParameters);
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally
  }


  /**
   * Price the sub total and any order level discounts. The OrderPriceInfo of the Order
   * will contain the raw subtotal for all the items, and the amount will include any
   * order level discounts. The tax and shipping are not set.
   * This method will regenerate order ranges if necessary
   * @return the total of the order, minus shipping and taxes
   * @param pOrder the order to price
   * @param pPricingModels the pricing models used in this pricing
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @exception PricingException if there was an error while computing the pricing information
   */
  protected double priceOrderForOrderTotal(Order pOrder,
      Collection pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    return priceOrderForOrderTotal(pOrder, pPricingModels, pLocale, pProfile, pExtraParameters, true);
  }

  /**
   * Price the sub total and any order level discounts. The OrderPriceInfo of the Order
   * will contain the raw subtotal for all the items, and the amount will include any
   * order level discounts. The tax and shipping are not set.
   * This method assumes the commerce item ranges have been generated.
   * @return the total of the order, minus shipping and taxes
   * @param pOrder the order to price
   * @param pPricingModels the pricing models used in this pricing
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @param pGenerateOrderRanges If this is true, <code>CommerceItemManager.generateRangesForOrder</code>
   * @exception PricingException if there was an error while computing the pricing information
   * @see atg.commerce.order.CommerceItemManager#generateRangesForOrder
   */
  protected double priceOrderForOrderTotal(Order pOrder,
      Collection pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters,
      boolean pGenerateOrderRanges)
  throws PricingException
  {
    String perfName = "priceOrderForOrderTotal2";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean cancelPerfMonitor = false;

    synchronized (pOrder) {
      try {
        // make sure the ranges are in place
        if(pGenerateOrderRanges)
          getCommerceItemManager().generateRangesForOrder(pOrder);

        Map extras = pExtraParameters;
        if(extras == null)
          extras = new HashMap();
        OrderPriceInfo info = getOrderPricingEngine().priceOrder(pOrder,
            pPricingModels,
            pLocale,
            pProfile,
            extras);
        OrderPriceInfo oldPriceInfo = pOrder.getPriceInfo();
        pOrder.setPriceInfo(info);
        if (isSendPromotionClosenessMessages())
          compareQualifiers(oldPriceInfo, info, pOrder, pProfile);
        if (info != null)
          return info.getAmount();
        else
          return 0.0;
      }
      catch (PricingException pe) {
        // Catch pricing exceptions from OrderPricingEngine.priceOrder & rethrow exception
        cancelPerfMonitor = true;
        throw pe;
      }
      catch (CommerceException ce) {
        // Catch commerce exceptions from generateRangesForOrder
        cancelPerfMonitor = true;
        throw new PricingException(ce);
      }
      finally {
        try {
          if (cancelPerfMonitor)
            PerformanceMonitor.cancelOperation(PERFORM_MONITOR_NAME, perfName);
          else
            PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
        } catch (PerfStackMismatchException e) {
          if (isLoggingWarning())
            logWarning(e);
        }
      }
    }
  }

  /**
   * Price the taxes for the entire order. The pricing models are gathered from the
   * Tax Pricing Engine using the profile.
   * This method will regenerate order ranges if necessary
   * @return the total amount in taxes
   * @param pOrder the order to price
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @exception PricingException if there was an error while computing the pricing information
   */
  public double priceTaxForOrderTotal(Order pOrder,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    Collection taxPricingModels =  getTaxPricingEngine().getPricingModels(pProfile);
    return priceTaxForOrderTotal(pOrder, taxPricingModels, pLocale, pProfile, pExtraParameters);
  }

  /**
   * Price the taxes for the entire order. The pricing models are taken from the supplied PricingModelHolder.
   * This method will regenerate order ranges if necessary
   * @return the total amount in taxes
   * @param pOrder the order to price
   * @param pPricingModels the PricingModelHolder is an object which contains all the
   * pricing models associated with a user (i.e. item, shipping, order and tax).
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @exception PricingException if there was an error while computing the pricing information
   */
  public double priceTaxForOrderTotal(Order pOrder,
      PricingModelHolder pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "priceTaxForOrderTotal";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {
      Collection taxPricingModels =  null;
      if (pPricingModels != null) {
        taxPricingModels =  pPricingModels.getTaxPricingModels();
      }
      return priceTaxForOrderTotal(pOrder, taxPricingModels, pLocale, pProfile, pExtraParameters);
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally
  }

  /**
   * Price the taxes for the entire order
   * This method will regenerate order ranges if necessary
   * @return the total amount in taxes
   * @param pOrder the order to price
   * @param pPricingModels the pricing models used in this pricing
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @exception PricingException if there was an error while computing the pricing information
   */
  public double priceTaxForOrderTotal(Order pOrder,
      Collection pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    return priceTaxForOrderTotal(pOrder, pPricingModels, pLocale, pProfile, pExtraParameters, true);
  }

  /**
   * Price the taxes for the entire order
   * @return the total amount in taxes
   * @param pOrder the order to price
   * @param pPricingModels the pricing models used in this pricing
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @param pGenerateOrderRanges If this is true, <code>CommerceItemManager.generateRangesForOrder</code>
   * @exception PricingException if there was an error while computing the pricing information
   * @see atg.commerce.order.CommerceItemManager#generateRangesForOrder
   */
  protected double priceTaxForOrderTotal(Order pOrder,
      Collection pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters,
      boolean pGenerateOrderRanges)
  throws PricingException
  {
    String perfName = "priceTaxForOrderTotal2";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean cancelPerfMonitor = false;

    synchronized (pOrder) {
      try {
        // make sure the ranges are in place
        if(pGenerateOrderRanges)
          getCommerceItemManager().generateRangesForOrder(pOrder);

        Map extras = pExtraParameters;
        if(extras == null)
          extras = new HashMap();
        TaxPriceInfo info = getTaxPricingEngine().priceTax(pOrder,
            pPricingModels,
            pLocale,
            pProfile,
            extras);
        TaxPriceInfo oldPriceInfo = pOrder.getTaxPriceInfo();
        pOrder.setTaxPriceInfo(info);
        if (isSendPromotionClosenessMessages())
          compareQualifiers(oldPriceInfo, info, pOrder, pProfile);
        if (info != null)
          return info.getAmount();
        else
          return 0.0;
      }
      catch (PricingException pe) {
        // Rethrow any pricing exception generated by priceTax
        cancelPerfMonitor = true;
        throw pe;
      }
      catch (CommerceException ce) {
        // Catch commerce exceptions generated by getRangesForOrder
        cancelPerfMonitor = true;
        throw new PricingException(ce);
      }
      finally {
        try {
          if (cancelPerfMonitor)
            PerformanceMonitor.cancelOperation(PERFORM_MONITOR_NAME, perfName);
          else
            PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
        } catch (PerfStackMismatchException e) {
          if (isLoggingWarning()) {
            logWarning(e);
          }
        }
      }
    }
  }


  /**
   * Dispatch off of the Pricing Operation constant supplied to determine what type
   * of pricing should be performed. The operations which are acceptable are defined in the
   * <code>atg.commerce.pricing.PricingConstants</code> interface. They include:
   * <UL>
   * <LI>PricingConstants.OP_REPRICE_ORDER_TOTAL -> <code>ORDER_TOTAL</code>
   * <LI>PricingConstants.OP_REPRICE_ORDER_SUBTOTAL -> <code>ORDER_SUBTOTAL</code>
   * <LI>PricingConstants.OP_REPRICE_ORDER_SUBTOTAL_SHIPPING -> <code>ORDER_SUBTOTAL_SHIPPING</code>
   * <LI>PricingConstants.OP_REPRICE_ORDER_SUBTOTAL_TAX -> <code>ORDER_SUBTOTAL_TAX</code>
   * <LI>PricingConstants.OP_REPRICE_ITEMS -> <code>ITEMS</code>
   * <LI>PricingConstants.OP_REPRICE_SHIPPING -> <code>SHIPPING</code>
   * <LI>PricingConstants.OP_REPRICE_ORDER -> <code>ORDER</code>
   * <LI>PricingConstants.OP_REPRICE_TAX -> <code>TAX</code>
   * <LI>PricingConstants.OP_NO_REPRICE -> <code>NO_REPRICE</code>
   * </UL>
   * If this value is null, then the system will default to ORDER_TOTAL.
   * @param pPricingOperation the pricing operation to perform
   * @param pOrder the order to price
   * @param pPricingModels the PricingModelHolder is an object which contains all the
   * pricing models associated with a user (i.e. item, shipping, order and tax). If this is null,
   * then the pricing models are extracted from the profile through the pricing engines.
   * @param pLocale the locale of the user, may be null
   * @param pProfile the user, may be null
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   * @exception PricingException if there was an error while computing the pricing information
   */
  public void performPricingOperation(String pPricingOperation,
      Order pOrder,
      PricingModelHolder pPricingModels,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "performPricingOperation";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {
      // Reprice the whole order, including items, shipping and taxes
      if ((pPricingOperation == null) || (pPricingOperation.equalsIgnoreCase(PricingConstants.OP_REPRICE_ORDER_TOTAL))) {
        if (isLoggingDebug())
          logDebug("Price Order Total: pPricingOperation=" + pPricingOperation + "; order=" + pOrder + "; pProfile=" + pProfile + "; pLocale=" + pLocale + "; pPricingModels=" + pPricingModels + "; pExtraParameters=" + pExtraParameters);
        if (pPricingModels != null)
          priceOrderTotal(pOrder, pPricingModels, pLocale, pProfile, pExtraParameters);
        else
          priceOrderTotal(pOrder, pLocale, pProfile, pExtraParameters);
      }
      // Reprice items and calculate order subtotal
      else if (pPricingOperation.equalsIgnoreCase(PricingConstants.OP_REPRICE_ORDER_SUBTOTAL)) {
        if (isLoggingDebug())
          logDebug("Price Order Subtotal: pPricingOperation=" + pPricingOperation + "; order=" + pOrder + "; pProfile=" + pProfile + "; pLocale=" + pLocale + "; pPricingModels=" + pPricingModels + "; pExtraParameters=" + pExtraParameters);
        if (pPricingModels != null)
          priceOrderSubtotal(pOrder, pPricingModels, pLocale, pProfile, pExtraParameters);
        else
          priceOrderSubtotal(pOrder, pLocale, pProfile, pExtraParameters);
      }
      // Reprice items and calculate order subtotal and shipping, not taxes
      else if (pPricingOperation.equalsIgnoreCase(PricingConstants.OP_REPRICE_ORDER_SUBTOTAL_SHIPPING)) {
        if (isLoggingDebug())
          logDebug("Price Order Subtotal with shipping: pPricingOperation=" + pPricingOperation + "; order=" + pOrder + "; pProfile=" + pProfile + "; pLocale=" + pLocale + "; pPricingModels=" + pPricingModels + "; pExtraParameters=" + pExtraParameters);
        if (pPricingModels != null)
          priceOrderSubtotalShipping(pOrder, pPricingModels, pLocale, pProfile, pExtraParameters);
        else
          priceOrderSubtotalShipping(pOrder, pLocale, pProfile, pExtraParameters);
      }
      // Reprice items and calculate order subtotal and taxes, not shipping
      else if (pPricingOperation.equalsIgnoreCase(PricingConstants.OP_REPRICE_ORDER_SUBTOTAL_TAX)) {
        if (isLoggingDebug())
          logDebug("Price Order Subtotal with taxes: pPricingOperation=" + pPricingOperation + "; order=" + pOrder + "; pProfile=" + pProfile + "; pLocale=" + pLocale + "; pPricingModels=" + pPricingModels + "; pExtraParameters=" + pExtraParameters);
        if (pPricingModels != null)
          priceOrderSubtotalTax(pOrder, pPricingModels, pLocale, pProfile, pExtraParameters);
        else
          priceOrderSubtotalTax(pOrder, pLocale, pProfile, pExtraParameters);
      }
      // Price items
      else if (pPricingOperation.equalsIgnoreCase(PricingConstants.OP_REPRICE_ITEMS)) {
        if (isLoggingDebug())
          logDebug("Price CommerceItems: pPricingOperation=" + pPricingOperation + "; order=" + pOrder + "; pProfile=" + pProfile + "; pLocale=" + pLocale + "; pPricingModels=" + pPricingModels + "; pExtraParameters=" + pExtraParameters);
        if (pPricingModels != null)
          priceItemsForOrderTotal(pOrder, pPricingModels, pLocale, pProfile, pExtraParameters);
        else
          priceItemsForOrderTotal(pOrder, pLocale, pProfile, pExtraParameters);
      }
      // Price shipping
      else if (pPricingOperation.equalsIgnoreCase(PricingConstants.OP_REPRICE_SHIPPING)) {
        if (isLoggingDebug())
          logDebug("Price ShippingGroups: pPricingOperation=" + pPricingOperation + "; order=" + pOrder + "; pProfile=" + pProfile + "; pLocale=" + pLocale + "; pPricingModels=" + pPricingModels + "; pExtraParameters=" + pExtraParameters);
        if (pPricingModels != null)
          priceShippingForOrderTotal(pOrder, pPricingModels, pLocale, pProfile, pExtraParameters);
        else
          priceShippingForOrderTotal(pOrder, pLocale, pProfile, pExtraParameters);
      }
      // Price order
      else if (pPricingOperation.equalsIgnoreCase(PricingConstants.OP_REPRICE_ORDER)) {
        if (isLoggingDebug())
          logDebug("Price Order object: pPricingOperation=" + pPricingOperation + "; order=" + pOrder + "; pProfile=" + pProfile + "; pLocale=" + pLocale + "; pPricingModels=" + pPricingModels + "; pExtraParameters=" + pExtraParameters);
        if (pPricingModels != null)
          priceOrderForOrderTotal(pOrder, pPricingModels, pLocale, pProfile, pExtraParameters);
        else
          priceOrderForOrderTotal(pOrder, pLocale, pProfile, pExtraParameters);
      }
      // Price taxes
      else if (pPricingOperation.equalsIgnoreCase(PricingConstants.OP_REPRICE_TAX)) {
        if (isLoggingDebug())
          logDebug("Calculate taxes: pPricingOperation=" + pPricingOperation + "; order=" + pOrder + "; pProfile=" + pProfile + "; pLocale=" + pLocale + "; pPricingModels=" + pPricingModels + "; pExtraParameters=" + pExtraParameters);
        if (pPricingModels != null)
          priceTaxForOrderTotal(pOrder, pPricingModels, pLocale, pProfile, pExtraParameters);
        else
          priceTaxForOrderTotal(pOrder, pLocale, pProfile, pExtraParameters);
      }
      else if (pPricingOperation.equalsIgnoreCase(PricingConstants.OP_NO_REPRICE)) {
        if (isLoggingDebug())
          logDebug("Perform NO Pricing: pPricingOperation=" + pPricingOperation + "; order=" + pOrder + "; pProfile=" + pProfile + "; pLocale=" + pLocale + "; pPricingModels=" + pPricingModels + "; pExtraParameters=" + pExtraParameters);
        return;
      }
      else {
        if (isLoggingDebug())
          logDebug("Price Order Total: pPricingOperation=" + pPricingOperation +"; order=" + pOrder + "; pProfile=" + pProfile + "; pLocale=" + pLocale + "; pPricingModels=" + pPricingModels + "; pExtraParameters=" + pExtraParameters);
        // default to complete order total
        if (pPricingModels != null)
          priceOrderTotal(pOrder, pPricingModels, pLocale, pProfile, pExtraParameters);
        else
          priceOrderTotal(pOrder, pLocale, pProfile, pExtraParameters);
      }
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally
  }


  /**
   * Determines whether a CommerceItem is taxable.
   * This default implementation always returns true (all items
   * are taxable by default).
   *
   * @param pItem the Item whose taxablility is in question
   * @param pItemPriceInfo the price of the item whose taxability is in question
   * @param pOrderPriceInfo the price of the order in which pItem resides
   * @param pOrder the order in which pItem resides
   * @param pShippingPriceInfo the price of the shippingGroup in which pItem resides
   * @param pShippingGroup the shippingGroup in which pItem resides
   * @param pLocale the locale in which the item is being taxed
   * @param pProfile the person for whom pItem may be taxed
   * @param pExtraParameters any extra information that this method may need to determine
   *        whether pItem is taxable.
   *
   * @return true if the item is taxable, false if it is not
   * @exception PricingException if something prevented PricingTools from
   *            determining whether the item is taxable.
   */
  public boolean isTaxable(CommerceItem pItem,
      ItemPriceInfo pItemPriceInfo,
      OrderPriceInfo pOrderPriceInfo,
      Order pOrder,
      ShippingPriceInfo pShippingPriceInfo,
      ShippingGroup pShippingGroup,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters) throws PricingException {
    return true;
  } // end isTaxable

  /**
   * Calculates the taxable amount of an item.  If the item is not
   * taxable (<code>isTaxable</code> is false) then 0.0 is returned.  Otherwise
   * the items order discount share is subtracted from its amount.
   *
   * @param pItem The CommerceItem whose taxable amount is returned
   * @param pOrder The order containing the item
   * @param pLocale The users locale
   * @param pProfile The current users profile
   * @param pExtraParameters any extra information that this method may need
   * @return the taxable amount of the item
   **/
  public double calculateTaxableAmount(CommerceItem pItem,
      Order pOrder,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "calculateTaxableAmount";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {
      if(isTaxable(pItem, pItem.getPriceInfo(), pOrder.getPriceInfo(), pOrder, null, null,
          pLocale, pProfile, pExtraParameters)) {
        ItemPriceInfo info = pItem.getPriceInfo();
        double amount = info.getAmount();
        double orderDisc = info.getOrderDiscountShare();
        double manualAdjustmentShare = calculateItemsOrderManualAdjustmentShare(pItem);
        amount -= orderDisc;
        amount +=manualAdjustmentShare;
        return amount;
      }
      else {
        return 0.0;
      }
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally
  }


  /**
   * Calculates the taxable amount of an relationship.  If the
   * relationship's item is not taxable (<code>isTaxable</code> is
   * false) then 0.0 is returned.  Otherwise the relationships order
   * discount share is subtracted from its amount.  These two numbers
   * are calculated by adding the relevant properties for each of the
   * details withing the same range as the relationship.
   *
   * @param pItem The CommerceItem whose taxable amount is returned
   * @param pOrder The order containing the item
   * @param pLocale The users locale
   * @param pProfile The current users profile
   * @param pExtraParameters any extra information that this method may need
   * @return The taxable amount of the relationship
   * @see #getShipItemRelPriceTotal
   **/
  public double calculateTaxableAmount(ShippingGroupCommerceItemRelationship pRelationship,
      Order pOrder,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "calculateTaxableAmount2";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {
      CommerceItem item = pRelationship.getCommerceItem();
      ShippingGroup sg = pRelationship.getShippingGroup();
      if(isTaxable(item, item.getPriceInfo(), pOrder.getPriceInfo(), pOrder, sg.getPriceInfo(), sg,
          pLocale, pProfile, pExtraParameters))
      {
        double amount = getShipItemRelPriceTotal(pRelationship, DETAILED_ITEM_PRICE_AMOUNT_PROPERTY);
        double orderDiscountShare = getShipItemRelPriceTotal(pRelationship,
            DETAILED_ITEM_PRICE_ORDER_DISCOUNT_SHARE_PROPERTY);
        double orderManualAdjustmentShare = getShipItemRelPriceTotal(pRelationship,
            DETAILED_ITEM_PRICE_ORDER_MANUAL_ADJUSTMENT_SHARE_PROPERTY);
        amount -= orderDiscountShare;
        amount += orderManualAdjustmentShare;
        return amount;
      }
      else {
        return 0.0;
      }
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally
  }

  /**
   * Adds up the manual adjustment share from the item's detailedItemPriceInfos
   * @param pCommerceItem
   * @return the manual adjustment share for the item
   */
  public double calculateItemsOrderManualAdjustmentShare(CommerceItem pCommerceItem)
  {
    double share = 0.0;
    List details = pCommerceItem.getPriceInfo().getCurrentPriceDetails();
    Iterator detailerator = details.iterator();
    DetailedItemPriceInfo dipi = null;
    while(detailerator.hasNext())
    {
      dipi = (DetailedItemPriceInfo)detailerator.next();
      share += dipi.getOrderManualAdjustmentShare();
    }
    return share;
  }

  /**
   * This method does the same thing as <code>calcualteTaxableAmount</code> except the 
   * an average amount is used for the items rather than the actual amount.  This is only
   * relevant if <code>shippingSubtotalUsesAverageItemPrice</code> is true.
   *
   * @param pItem The CommerceItem whose taxable amount is returned
   * @param pOrder The order containing the item
   * @param pLocale The users locale
   * @param pProfile The current users profile
   * @param pExtraParameters any extra information that this method may need
   * @return The taxable amount of the relationship
   * @see #getShipItemRelPriceTotal
   **/
  public double calculateTaxableAmountByAverage(ShippingGroupCommerceItemRelationship pRelationship,
      Order pOrder,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "calculateTaxableAmountByAcerage";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {
      CommerceItem item = pRelationship.getCommerceItem();
      ShippingGroup sg = pRelationship.getShippingGroup();
      if(isTaxable(item, item.getPriceInfo(), pOrder.getPriceInfo(), pOrder, sg.getPriceInfo(), sg,
          pLocale, pProfile, pExtraParameters))
      {
        long quantity = pRelationship.getQuantity();
        double averagePrice = getAverageItemPrice(item);
        double roundedAverage = round(averagePrice);
        return round(quantity * roundedAverage);
      }
      else {
        return 0.0;
      }
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally
  }

  /**
   * This method does the same thing as <code>calcualteTaxableAmount</code> except the 
   * an average amount is used for the items rather than the actual amount.  This is only
   * relevant if <code>shippingSubtotalUsesAverageItemPrice</code> is true.
   *
   * @param pRealationship The relationship whose taxable amount is returned
   * @param pOrder The order containing the item
   * @param pLocale The users locale
   * @param pProfile The current users profile
   * @param pExtraParameters any extra information that this method may need
   * @return The taxable amount of the relationship
   **/
  public double calculateTaxableAmountByAverage(CommerceItemRelationship pRelationship,
      Order pOrder,
      Locale pLocale,
      RepositoryItem pProfile,
      Map pExtraParameters)
  throws PricingException
  {
    String perfName = "calculateTaxableAmountByAverage";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {
      CommerceItem item = pRelationship.getCommerceItem();
      if(isTaxable(item, item.getPriceInfo(), pOrder.getPriceInfo(), pOrder, null, null,
          pLocale, pProfile, pExtraParameters))
      {
        long quantity = pRelationship.getQuantity();
        double averagePrice = getAverageItemPrice(item);
        double roundedAverage = round(averagePrice);
        return round(roundedAverage * quantity);
      }
      else {
        return 0.0;
      }
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally
  }
  
  /**
   * This method will return the average price for a given commerce item.
   * This is used when calculating the subtotal of a shipping group if
   * <code>shippingSubtotalUsesAverageItemPrice</code>
   * 
   * @param pCommerceItem The item whose average price is returned
   * @return The average price
   */
  public double getAverageItemPrice(CommerceItem pCommerceItem) {
    if(pCommerceItem == null)
      return 0.0;

    double amount = pCommerceItem.getPriceInfo().getAmount();
    ItemPriceInfo info = pCommerceItem.getPriceInfo();
    double orderDisc = info.getOrderDiscountShare();
    double manualAdjustmentShare = calculateItemsOrderManualAdjustmentShare(pCommerceItem);
    amount -= orderDisc;
    amount += manualAdjustmentShare;
    
    double averagePrice =  amount / pCommerceItem.getQuantity();

    // if we divided by zero... use zero instead
    if(Double.isNaN(averagePrice) || Double.isInfinite(averagePrice)) {
      if(isLoggingDebug()) {
        logDebug(MessageFormat.format(Constants.QUOTIENT_IS_NAN, "priceOrder", 
            Double.toString(pCommerceItem.getPriceInfo().getAmount()), 
            Double.toString(pCommerceItem.getQuantity()) ));
      }
      averagePrice = 0.0;
    }
    
    return averagePrice;
  }
  
  /**
   * This method determines whether the input number needs to be rounded
   * based on the value of the <code>roundingDecimalPlaces</code> property.
   * That is to say, if the input number has more decimal places than N,
   * where N is the value of <code>roundingDecimalPlaces</code>, then the
   * input number needs to be rounded.
   *
   * @param pNumber the number that may need to be rounded
   * @return true if the number needs to be rounded, false if it does not.
   */
  public boolean needsRounding (double pNumber) {
    /*
     * Excerpted from the javadoc for the BigDecimal constructor:
     *
     * Note: the results of this constructor can be somewhat
     * unpredictable. One might assume that new BigDecimal(.1) is
     * exactly equal to .1, but it is actually equal to
     * .1000000000000000055511151231257827021181583404541015625. This
     * is so because .1 cannot be represented exactly as a double
     * (or, for that matter, as a binary fraction of any finite
     * length). Thus, the long value that is being passed in to the
     * constructor is not exactly equal to .1, appearances
     * nonwithstanding.
     *
     *The (String) constructor, on the other hand, is perfectly
     *predictable: new BigDecimal(".1") is exactly equal to .1, as
     *one would expect. Therefore, it is generally recommended that
     *the (String) constructor be used in preference to this one.
     */
    BigDecimal bd = new BigDecimal(Double.toString(pNumber));
    int length = bd.scale();
    return length > getRoundingDecimalPlaces();
  }

  /**
   * Rounds the input number to the number of decimal places specified by the
   * <code>roundingDecimalPlaces</code> property.  Rounds 1 through 4 down,
   * and 5 through 9 up.
   *
   * @param pNumber the number to be rounded
   * @return pNumber, rounded to the nearest [roundingDecimalPlaces] decimal points
   */
  public double round (double pNumber) {
    return round(pNumber,getRoundingDecimalPlaces());
  }

  /**
   * Rounds the input number to the number of decimal places specified by the
   * <code>pRoundingDecimalPlaces</code> argument.  Rounds 1 through 4 down,
   * and 5 through 9 up.
   *
   * @param pNumber the number to be rounded
   * @param pRoundingDecimalPlaces the number of decimal places to round to
   * @return pNumber, rounded to the nearest [roundingDecimalPlaces] decimal points
   */
  public double round (double pNumber, int pRoundingDecimalPlaces) {
    /*
     * Excerpted from the javadoc for the BigDecimal constructor:
     *
     * Note: the results of this constructor can be somewhat
     * unpredictable. One might assume that new BigDecimal(.1) is
     * exactly equal to .1, but it is actually equal to
     * .1000000000000000055511151231257827021181583404541015625. This
     * is so because .1 cannot be represented exactly as a double
     * (or, for that matter, as a binary fraction of any finite
     * length). Thus, the long value that is being passed in to the
     * constructor is not exactly equal to .1, appearances
     * nonwithstanding.
     *
     *The (String) constructor, on the other hand, is perfectly
     *predictable: new BigDecimal(".1") is exactly equal to .1, as
     *one would expect. Therefore, it is generally recommended that
     *the (String) constructor be used in preference to this one.
     */
    BigDecimal bd = new BigDecimal(Double.toString(pNumber));
    bd = bd.setScale(pRoundingDecimalPlaces, BigDecimal.ROUND_HALF_UP);
    return bd.doubleValue(); 
  }

  /**
   * Rounds the input number to the number of decimal places specified by the
   * <code>roundingDecimalPlaces</code> property.  Rounds all numbers beyond the
   * desired number of decimal places to zero.
   *
   * @param pNumber the number to be rounded
   * @return pNumber, rounded to the nearest [roundingDecimalPlaces] decimal points
   */
  public double roundDown (double pNumber) {
    /*
     * Excerpted from the javadoc for the BigDecimal constructor:
     *
     * Note: the results of this constructor can be somewhat
     * unpredictable. One might assume that new BigDecimal(.1) is
     * exactly equal to .1, but it is actually equal to
     * .1000000000000000055511151231257827021181583404541015625. This
     * is so because .1 cannot be represented exactly as a double
     * (or, for that matter, as a binary fraction of any finite
     * length). Thus, the long value that is being passed in to the
     * constructor is not exactly equal to .1, appearances
     * nonwithstanding.
     *
     *The (String) constructor, on the other hand, is perfectly
     *predictable: new BigDecimal(".1") is exactly equal to .1, as
     *one would expect. Therefore, it is generally recommended that
     *the (String) constructor be used in preference to this one.
     */
    BigDecimal bd = new BigDecimal(Double.toString(pNumber));
    bd = bd.setScale(getRoundingDecimalPlaces(), BigDecimal.ROUND_DOWN);
    return bd.doubleValue();
  }

  /**
   * Sum the amount for all the details that refer to a specific relationship
   * If the range of the relationship is null, 0.0 is returned.
   * This method assumes the relationship has a range
   *
   * @param pRelationship The relationship to return the subtotal for, using the details within
   *                      the same range
   * @param pDetailProperty
   * @return The relationships subtotal, or 0.0 if the relationship, or it's range is null
   **/
  public double getShipItemRelPriceTotal(ShippingGroupCommerceItemRelationship pRelationship,
      String pDetailProperty)
  throws PricingException
  {
    String perfName = "getShipItemRelPriceTotal";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {
      if(pRelationship == null) {
        if(isLoggingDebug())
          logDebug("Relationship is null, return 0.0 as subtotal");
        return 0.0;
      }

      Range relRange = pRelationship.getRange();

      if(relRange == null) {
        if(isLoggingDebug())
          logDebug("Relationship's range is null, return 0.0 as subtotal");
      }

      CommerceItem commerceItem = pRelationship.getCommerceItem();

      ItemPriceInfo itemPrice = commerceItem.getPriceInfo();
      List details = itemPrice.getCurrentPriceDetailsForRange(relRange);
      double totalPrice = 0.0;
      if(details != null) {
        Iterator detailerator = details.iterator();
        // sum the totals of all the details for this relationship
        while(detailerator.hasNext()) {
          DetailedItemPriceInfo detail = (DetailedItemPriceInfo) detailerator.next();

          // we are assuming that no DetailedItemPriceInfo refers to items in two
          // different shipping groups
          double detailPrice;
          try {
            Double amount = (Double) DynamicBeans.getPropertyValue(detail, pDetailProperty);
            detailPrice = amount.doubleValue();
          }
          catch(PropertyNotFoundException pnf) {
            try {
              if(!perfCancelled) {
                PerformanceMonitor.cancelOperation(PERFORM_MONITOR_NAME, perfName);
                perfCancelled = true;
              }
            }
            catch(PerfStackMismatchException psm) {
              if(isLoggingWarning())
                logWarning(psm);
            }

            throw new PricingException(pnf);
          }

          totalPrice += detailPrice;
        }
      }
      return totalPrice;
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally
  }

  /**
   * This method will return the sum of the amounts of all the
   * DetailedItemPriceInfos that refer to an item in any of these
   * relationship.  The details are identified by comparing the range
   * of the detail to the range of the relationship
   *
   * @param pRelationships The list of relationships to get the amounts for
   * @param pDetailProperty The name of the property in the relationships DetailedItemPriceInfos to sum
   * @return the sum of the amounts of all the Details for all the relationships
   **/
  public double getRelationshipsSubtotal(List pRelationships, String pDetailProperty)
  throws PricingException
  {
    String perfName = "getRelationshipsSubtotal";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {
      long totalQuantity = 0;
      double totalAmount = 0.0;
      Iterator relationshipIterator = pRelationships.iterator();
      while (relationshipIterator.hasNext()) {

        ShippingGroupCommerceItemRelationship rel = (ShippingGroupCommerceItemRelationship) relationshipIterator.next();

        // get the item and the quantity of the item that is in this relationship.
        // switch on type of relationship to get the actual quantity that the relationship
        // represents

        long relationshipQuantity = 0;
        CommerceItem item = rel.getCommerceItem();

        relationshipQuantity = rel.getRange().getSize();

        if (isLoggingDebug()) {
          logDebug("total quantity of item: " + item.getId() + " to add to order total: " + relationshipQuantity);
        }

        // if there's no quantity in this rel, skip it
        if (relationshipQuantity == 0) {
          if (isLoggingDebug()) {
            logDebug("no quantity of this relationship to add, continuing.");
          }
          continue;
        }

        totalQuantity += relationshipQuantity;

        double relationshipSubtotal = getShipItemRelPriceTotal(rel, pDetailProperty);

        // add the relationship subtotal to the total amount
        totalAmount += relationshipSubtotal;

        /**
         * sometimes double math produces 'equivalent', yet not exactly identical
         * numbers.  For example, it appears that the numbers:
         *   .03
         * and
         *   .030000000000001137
         * are numerically equivalent as far as double calculations are concerned.
         * Double calculations sometimes produce these strange numbers despite the
         * fact that the number of decimal places can't possibly be that large.
         * We're going to round the products of double math to N places, with the
         * understanding that all numbers in DCS are going to be rounded to N places.
         */

        totalAmount = round(totalAmount);

        if (isLoggingDebug()) {
          logDebug("after rounding, relationships subtotal: " + totalAmount);
        }
      } // end for each relationship

      return totalAmount;
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally
  }

  /**
   * Get a particular items order discount share.  A particular items
   * share of an order discount is proportional to the items share of
   * the entire order cost.
   *
   * @param pOrder The order containing the item
   * @param pItem The commerce item
   * @param pDiscount The size of the discount
   **/
  public double getItemsOrderDiscountShare(Order pOrder, CommerceItem pItem, double pDiscount)
  {
    String perfName = "getItemsOrderDiscountShare";
    PerformanceMonitor.startOperation(PERFORM_MONITOR_NAME, perfName);
    boolean perfCancelled = false;

    try {
      double orderPrice = pOrder.getPriceInfo().getAmount();
      double itemPrice = pItem.getPriceInfo().getAmount();
      double ratio = itemPrice / orderPrice;
      return ratio * pDiscount;
    }
    finally {
      try {
        if(!perfCancelled) {
          PerformanceMonitor.endOperation(PERFORM_MONITOR_NAME, perfName);
          perfCancelled = true;
        }
      } catch (PerfStackMismatchException e) {
        if (isLoggingWarning()) {
          logWarning(e);
        }
      }
    }// end finally
  }

  /**
   * Return a price for the given quantity of the product and sku.  It will not
   * take any promotions into consideration.  The current session scoped profile is
   * used as well as the default locale.
   *
   * @param pProduct The product being priced
   * @param pSku The sku being priced
   * @param pQuantity The quantity of the sku being priced
   * @return An ItemPriceInfo
   **/
  public ItemPriceInfo calculatePrice(RepositoryItem pProduct, RepositoryItem pSku,
      long pQuantity)
  throws PricingException
  {
    RepositoryItem profile = ServletUtil.getCurrentUserProfile();
    Locale locale = getDefaultLocale();
    return calculatePrice(pProduct, pSku, pQuantity, true, profile, locale, null);
  }

  /**
   * Return a price for the given quantity of the product and sku
   *
   * @param pProduct The product being priced
   * @param pSku The sku being priced
   * @param pQuantity The quantity of the sku being priced
   * @param pIgnorePromotions If true, then no promotions will be considered.  If false
   *                          then promotions as calculated by priceItem will apply
   * @param pProfile The profile used during the price calculation
   * @param pLocale The locale used during the price calculation
   * @param pExtraParameters Any extra parameters that should be considered
   * @return An ItemPriceInfo
   **/
  public ItemPriceInfo calculatePrice(RepositoryItem pProduct, RepositoryItem pSku,
      long pQuantity, boolean pIgnorePromotions ,
      RepositoryItem pProfile, Locale pLocale,
      Map pExtraParameters)
  throws PricingException
  {
    PricingCommerceItem item = (PricingCommerceItem)(DictionaryThread.getObject(mCommerceItemKey));
    if (item == null) {
      item = new PricingCommerceItem();
    }
    else
      item.clear();

    item.setCatalogRefId(pSku.getRepositoryId());
    item.setQuantity(pQuantity);
    item.setPriceInfo(new ItemPriceInfo());

    AuxiliaryData aux = item.getAuxiliaryData();
    aux.setCatalogRef(pSku);
    aux.setProductId(pProduct.getRepositoryId());
    aux.setProductRef(pProduct);

    Collection models = null;
    if(pIgnorePromotions)
      priceItem(item, models, pLocale, pProfile, pExtraParameters);
    else
      priceItem(item, pLocale, pProfile, pExtraParameters);

    return item.getPriceInfo();
  }

  /**
   * Return a ShippingGroupCommerceItemRelationship based on the commerceItem and a DetailedItemPriceInfo.
   * It will look through all the ShippingGroupCommerceItemRelationships for that commerceItem and return
   * the one that the range of the DetailedItemPriceInfo lies within the range of that ShippingGroupCommerceItemRelationship.
   *
   * @param pItem The commerceItem
   * @param pPriceInfo The DetailedItemPriceInfo
   * @return ShippingGroupCommerceItemRelationship
   **/
  public ShippingGroupCommerceItemRelationship getShippingGroupCommerceItemRelationship(CommerceItem pItem,
      DetailedItemPriceInfo pPriceInfo)
  {
    Range priceRange = pPriceInfo.getRange();
    List commerceItemShippingGroupRelationships = pItem.getShippingGroupRelationships();
    Iterator i = commerceItemShippingGroupRelationships.iterator();
    while (i.hasNext()) {
      ShippingGroupCommerceItemRelationship sgcir = (ShippingGroupCommerceItemRelationship) i.next();
      Range r = sgcir.getRange();
      if (r != null && priceRange != null) {
        if (r.getLowBound() >= priceRange.getLowBound() &&
            r.getHighBound() <= priceRange.getHighBound()) {
          return sgcir;
        }
      }
    }
    return null;
  }
 /**
     * Returns a new instance of the class defined through the <code>OrderTools.defaultOrderPriceInfoClass</code>
     * property.
     * @exception PricingException if there was a problem instantiating the object
     */
   public OrderPriceInfo createOrderPriceInfo() throws PricingException {
       Class defaultOrderPriceInfoClass = getOrderTools().getDefaultOrderPriceInfoClass();

       if (defaultOrderPriceInfoClass == null) {
           String msg = ResourceUtils.getMsgResource("defaultOrderPriceInfoClassIsNull", MY_RESOURCE_NAME, sResourceBundle);
           throw new PricingException(msg);
       }

       try {
           return (OrderPriceInfo) defaultOrderPriceInfoClass.newInstance();
       } catch(InstantiationException e) {
           throw new PricingException(e);
       } catch(IllegalAccessException e) {
           throw new PricingException(e);
       }
   }
  /**
   * Returns a new instance of the class defined through the <code>subSkuPriceInfoClass</code>
   * property.
   * @exception PricingException if there was a problem instantiating the object
   */
  protected AmountInfo createSubSkuPriceInfo()
  throws PricingException
  {
    if (getSubSkuPriceInfoClass() == null) {
      String msg = ResourceUtils.getMsgResource("priceInfoClassIsNull", MY_RESOURCE_NAME, sResourceBundle);
      throw new PricingException(msg);
    }

    try {
      return (AmountInfo)getSubSkuPriceInfoClass().newInstance();
    }
    catch (InstantiationException e) {
      throw new PricingException(e);
    }
    catch (IllegalAccessException e) {
      throw new PricingException(e);
    }
  }

  /**
   * Returns a new instance of the of the class defined through the
   * <code>detailedItemPriceInfoClass</code> property.
   * @exception PricingException if there was a problem instantiating the object 
   **/
  public DetailedItemPriceInfo createDetailedItemPriceInfo()
  throws PricingException
  {
    if (getDetailedItemPriceInfoClass() == null) {
      String msg = Constants.DETAILED_ITEM_PRICE_INFO_CLASS_IS_NULL;
      throw new PricingException(msg);
    }

    try {
      return (DetailedItemPriceInfo)getDetailedItemPriceInfoClass().newInstance();
    }
    catch (InstantiationException e) {
      throw new PricingException(e);
    }
    catch (IllegalAccessException e) {
      throw new PricingException(e);
    }
  }

  /**
   * Returns a new instance of the of the class defined through the
   * <code>detailedItemPriceInfoClass</code> property.
   * This method also calls detailedItemPriceInfo.copyDetailProperties with
   * the given detail
   * @exception PricingException if there was a problem instantiating the object 
   **/
  public DetailedItemPriceInfo createDetailedItemPriceInfo(DetailedItemPriceInfo pDetailedItemPriceInfo)
  throws PricingException
  {
    DetailedItemPriceInfo detail = createDetailedItemPriceInfo();
    detail.copyDetailProperties(pDetailedItemPriceInfo);
    return detail;
  }



  /**
   * Create the initial DetailedItemPriceInfos with the given price for the given range
   *
   * @param pTotalPrice The total price that the new DetailedItemPriceInfos must account for
   * @param pPriceQuote The current working price of <code>pItem</code>.
   * @param pItem The item that is currently being priced.
   * @param pPricingModel the discount that will be set in the PricingAdjustment (usually null)
   * @param pProfile the person for whom the items are to be discounted (currently ignored)
   * @param pLocale the locale in which the items are to be discounted (currently ignored)
   * @param pExtraParameters any extra information that this method might need to set the
   *        prices of a number of the qualifying item (currently ignored)
   * @param pAdjustmentDescription This is the adjustment description used when creating all new PricingAdjustments
   * @return The newly created detail item price info
   **/
  protected DetailedItemPriceInfo createInitialSubSkuDetailedPriceInfo(double pTotalPrice, ItemPriceInfo pPriceQuote, 
      CommerceItem pItem, RepositoryItem pPricingModel, 
      Locale pLocale, RepositoryItem pProfile, 
      Map pExtraParameters,
      String pAdjustmentDescription, Range pRange)
  throws PricingException
  {
    DetailedItemPriceInfo details = createDetailedItemPriceInfo();
    long quantity = pItem.getQuantity();

    Range range = null;
    try {
      range = (Range) Class.forName(getRangeClassType()).newInstance();
    }
    catch(InstantiationException ie) {
      // because this class is not in nucleus (it doesn't have a properties file,
      // we need to use pricing tools for logging
      if(isLoggingDebug())
        logDebug("Cannot instantiate " + getRangeClassType() + ", so using atg.core.util.Range instead.");
      range = new Range();
    }
    catch(IllegalAccessException ie) {
      if(isLoggingDebug())
        logDebug("Illegal access to " + getRangeClassType() + ", so using atg.core.util.Range instead.");
      range = new Range();
    }
    catch(ClassNotFoundException ie) {
      if(isLoggingDebug())
        logDebug("Class " + getRangeClassType() + " not found, so using atg.core.util.Range instead.");
      range = new Range();
    }

    // this is the normal case.  Really, the only time this isn't the case is when
    // doing tiered pricing.
    if(pRange == null) {
      range.setLowBound(0);
      range.setHighBound(quantity - 1);
    }
    else {
      range.setLowBound(pRange.getLowBound());
      range.setHighBound(pRange.getHighBound());
    }

    details.setRange(range);
    details.setQuantity(quantity);
    details.setAmount(pTotalPrice);
    details.setCurrencyCode(pPriceQuote.getCurrencyCode());

    if(isLoggingDebug())
      logDebug("Creating Detailed price info for subsku. quantity is " + quantity + " price " + pTotalPrice);

    // set the first (list price) adjustment
    double adjustAmount = pTotalPrice;
    PricingAdjustment adjustment =
      new PricingAdjustment(pAdjustmentDescription,
          null,
          round(adjustAmount),
          quantity);
    details.getAdjustments().add(adjustment);

    // set the itemPriceInfo
    details.setItemPriceInfo(pPriceQuote);
    return details;
  }


  /**
   * Create and set the priceinfo object for a subsku. It will set the list price, amount,
   * raw price, detailed price and adjustments for the subsku
   *
   * @param pSubItem The commerce item corresponding to the sku that need to be priced
   * @param pUnitPrice The working price of the single subsku
   * @param pAdjustment The adjustment associated with this price computation.
   * @param pPricingModel A RepositoryItem representing a PricingModel
   * @param pLocale The user's locale
   * @param pProfile The user's profile
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   *                         You may override the price list in the profile by providing a price
   *                         list (or price list id) in this map.  Use <code>profilePriceListPropertyName</code>
   *                         as the key
   * @param pMsg This is the adjustment description used when creating new PricingAdjustments
   * @param pPriceList The priceInfo's pricelist is set to this object.
   *
   **/
  public void setSubSkuPrice(CommerceItem pSubItem, double pUnitPrice, 
      PricingAdjustment pAdjustment, RepositoryItem pPricingModel, 
      Locale pLocale, RepositoryItem pProfile, Map pExtraParameters, 
      String pMsg, RepositoryItem pPriceList)
  throws PricingException
  {
    ItemPriceInfo itemPrice = pSubItem.getPriceInfo();

    if(itemPrice != null) {

      if(itemPrice.isAmountIsFinal()) {
        return; // If amount is final, then we are done.
      }
    }

    long quantity = pSubItem.getQuantity();

    /* Create a new price info. For top level skus, the price info is computed by the ItemPricingEngine. For subsksus,
         it needs to be created here */
    itemPrice = (ItemPriceInfo) createSubSkuPriceInfo();
    pSubItem.setPriceInfo(itemPrice);

    double totalPrice = round(pUnitPrice * quantity);
    pUnitPrice = round(pUnitPrice);

    // set the total price of the item before discounts, this will be unaffected by later calcs
    itemPrice.setRawTotalPrice(totalPrice);

    // set the list price of the item before discounts, this will be unaffected by later calcs
    itemPrice.setListPrice(pUnitPrice);

    itemPrice.setPriceList(pPriceList); // set the price list for priceInfo object.

    // set the ItemPriceInfo's amount to the above price
    itemPrice.setAmount(totalPrice);

    if(isLoggingDebug())
      logDebug("Setting the price of subsku. Amount is " + totalPrice + " list price is " + pUnitPrice);

    // Create a new detailed price info object. Similar to the priceInfo, e also need to create DetailedPriceInfo object.

    List detailsList = new ArrayList(1);

    DetailedItemPriceInfo details = createInitialSubSkuDetailedPriceInfo(totalPrice,
        itemPrice,
        pSubItem,
        pPricingModel,
        pLocale,
        pProfile,
        pExtraParameters,
        Constants.LIST_PRICE_ADJUSTMENT_DESCRIPTION,null);

    // set the itemPriceInfo
    detailsList.add(details);

    itemPrice.setCurrentPriceDetails(detailsList);

    // set the ItemPriceInfo's detailedAmountInfo for future discounting
    List adjustments = itemPrice.getAdjustments();
    adjustments.add(pAdjustment);

  }

  /**
   * Update the priceinfo object for a subsku with a sale price.  This assumes the setSubSkuPrice
   * method has already been called.
   *
   * @param pSubItem The commerce item corresponding to the sku that need to be priced
   * @param pSalePrice The working price of the single subsku
   * @param pAdjustment The adjustment associated with this price computation.
   * @param pPricingModel A RepositoryItem representing a PricingModel
   * @param pLocale The user's locale
   * @param pProfile The user's profile
   * @param pExtraParameters A Map of extra parameters to be used in the pricing, may be null
   *                         You may override the price list in the profile by providing a price
   *                         list (or price list id) in this map.  Use <code>profilePriceListPropertyName</code>
   *                         as the key
   * @param pMsg This is the adjustment description used when creating new PricingAdjustments
   * @param pPriceList The priceInfo's pricelist is set to this object.
   *
   **/
  public void setSubSkuSalePrice(CommerceItem pSubItem, double pSalePrice, 
      PricingAdjustment pAdjustment, RepositoryItem pPricingModel, 
      Locale pLocale, RepositoryItem pProfile, Map pExtraParameters, 
      String pMsg, RepositoryItem pPriceList)
  throws PricingException
  {
    ItemPriceInfo itemPrice = pSubItem.getPriceInfo();

    if(itemPrice != null) {

      if(itemPrice.isAmountIsFinal()) {
        return; // If amount is final, then we are done.
      }
    }

    long quantity = pSubItem.getQuantity();

    double totalPrice = round(pSalePrice * quantity);
    double salePrice = round(pSalePrice);

    // set the total price of the item before discounts, this will be unaffected by later calcs
    itemPrice.setRawTotalPrice(totalPrice);

    // set the sale price of the item before discounts, this will be unaffected by later calcs
    itemPrice.setSalePrice(salePrice);
    itemPrice.setOnSale(true);

    // set the ItemPriceInfo's amount to the above price
    itemPrice.setAmount(totalPrice);

    if(isLoggingDebug())
      logDebug("Setting the price of subsku. Amount is " + totalPrice + " sale price is " + salePrice);

    // Create a new detailed price info object. Similar to the priceInfo, e also need to create DetailedPriceInfo object.

    List detailsList = itemPrice.getCurrentPriceDetails();
    getDetailedItemPriceTools().assignSalePriceToDetails(detailsList, salePrice,
        itemPrice, pSubItem,
        pPricingModel, pLocale, pProfile,
        pExtraParameters,
        pMsg);

    // set the ItemPriceInfo's detailedAmountInfo for future discounting
    List adjustments = itemPrice.getAdjustments();
    adjustments.add(pAdjustment);

  }

  /**
   * Checks to see if the closenessQualifiers in the pClosenessQualifiers1 parameter
   * are contained in pClosenessQualifiers2.  If not, then a message of type
   * pJMS type is sent.
   * 
   * This method is called twice per pricing operation - once with the new 
   * closenessQualifiers as pClosenessQualifiers1 and the old closenessQualifiers
   * as pClosenessQualifiers2, and once vice-versa.  The former call sends
   * PromotionClosenessQualification messages, the latter sends 
   * PromotionClosenessDisqualification messages.
   *  
   * @param pClosenessQualifiers1 the Map of closenessQualifiers that are to be
   *        compared against pClosenessQualifiers2
   * @param pClosenessQualifiers2 the Map of closenessQualifiers that 
   *        pClosenessQualifiers1 is to be compared against.
   * @param pJMSType the JMS type of the message to send if a closenessQualifier
   *        found in pClosenessQualifiers1 is not contained in pClosenessQualifiers2
   * @param pOrder the order that the closenessQualifiers pertain to
   * @param pProfile the owner of the order
   */
  public void compareClosenessQualifiers(List pClosenessQualifiers1, 
      List pClosenessQualifiers2, String pJMSType,
      Order pOrder, RepositoryItem pProfile) {


    if (isLoggingDebug())
      logDebug("Comparing closenessQualifiers.  pClosenessQualifiers1 = " +
          pClosenessQualifiers1 + ", pClosenessQualifiers2 = " + 
          pClosenessQualifiers2);

    if (pClosenessQualifiers1 == null) return;

    Iterator qualifierIterator = pClosenessQualifiers1.iterator();
    while (qualifierIterator.hasNext()) {
      boolean fireMessage = false;
      RepositoryItem closenessQualifier = (RepositoryItem) qualifierIterator.next();

      // Two ways to trigger firing of a message:
      // - If pClosenessQualifiers2 is null, it obviously doesn't contain the
      //   closenessQualifier
      // - If pClosenessQualifiers2 doesn't contain the closenessQualifer
      if (pClosenessQualifiers2 == null) fireMessage = true;
      else if (!pClosenessQualifiers2.contains(closenessQualifier)) 
        fireMessage = true;

      if (fireMessage)
        firePromotionClosenessMessage(pJMSType, pOrder, pProfile, 
            closenessQualifier); 
    }
  }				      

  protected void compareQualifiers(AmountInfo pOldPriceInfo, AmountInfo pNewPriceInfo,
      Order pOrder, RepositoryItem pProfile) {

    List oldPriceInfoClosenessQualifiers = null;
    if (pOldPriceInfo != null) 
      oldPriceInfoClosenessQualifiers = pOldPriceInfo.getClosenessQualifiers();
    List newPriceInfoClosenessQualifiers = pNewPriceInfo.getClosenessQualifiers();
    compareClosenessQualifiers(newPriceInfoClosenessQualifiers, oldPriceInfoClosenessQualifiers,
        getPromotionClosenessQualificationJMSType(), pOrder, pProfile);
    compareClosenessQualifiers(oldPriceInfoClosenessQualifiers, newPriceInfoClosenessQualifiers,
        getPromotionClosenessDisqualificationJMSType(), pOrder, pProfile);
  }

  /**
   * Constructs and sends a PromotionClosenessMessage of the given JMS type 
   * (PromotionClosenessQualification or PromotionClosenessDisqualification)
   * 
   * @param pJMSType The JMS type of the message
   * @param pOrder The order that the closenessQualifier is associated with
   * @param pProfile The owner of the order
   * @param pPromotion The promotion that is close to being qualified for
   * @param pClosenessQualifier The closenessQualifier that the order satisfies
   */
  public void firePromotionClosenessMessage(String pJMSType, Order pOrder, 
      RepositoryItem pProfile,
      RepositoryItem pClosenessQualifier) {

    if (!isSendPromotionClosenessMessages()) return;

    PromotionClosenessMessage message = new PromotionClosenessMessage();
    message.setType(pJMSType);
    message.setOrder(pOrder);
    message.setProfile(pProfile);
    message.setClosenessQualifier(pClosenessQualifier);
    message.setSiteId(SiteContextManager.getCurrentSiteId());
    sendPromotionClosenessQualificationMessage(message); 
  }

  /**
   * Sends the given PromotionClosenessMessage.
   * 
   * @param pMessage the message to send
   * 
   */
  protected void sendPromotionClosenessQualificationMessage(PromotionClosenessMessage pMessage) {

    if ( pMessage == null)
      return;

    try {
      if ( isLoggingDebug())
        logDebug("Sending scenario event with message: " + pMessage);

      getClosenessQualificationMessageSender().sendCommerceMessage(pMessage);
    }
    catch(javax.jms.JMSException exc)
    {
      if (isLoggingError())
        logError(exc);
    }
  }

  /**
   * Returns true if the order contains any price lists on 
   * the commerce item price info objects
   * @param pOrder
   * @return true if there is at least one price list found in the
   * commerce item pricing information. 
   */
  public boolean doesOrderContainPriceLists(Order pOrder)
  {
    if(pOrder.getCommerceItemCount() > 0) 
    {
      List items = pOrder.getCommerceItems();
      Iterator itemerator = items.iterator();
      while(itemerator.hasNext()) 
      {
        CommerceItem commerceItem = (CommerceItem) itemerator.next();
        ItemPriceInfo priceInfo = commerceItem.getPriceInfo();
        if(priceInfo != null && priceInfo.getPriceList() != null) 
          return true;
      }
    }
    return false;
  }



  /**
   * Returns the list price list from the order.
   * <p>
   * The price list is found by looking for a commerce item that is not on sale
   * with a price list associated. 
   *  
   * @param pOrder
   * @return price list item
   */
  public RepositoryItem getListPriceListFromOrder(Order pOrder) 
  {
    //extract a price list from one of the order's items.
    if(pOrder.getCommerceItemCount() > 0) 
    {
      List items = pOrder.getCommerceItems();
      Iterator itemerator = items.iterator();
      while(itemerator.hasNext()) 
      {
        CommerceItem commerceItem = (CommerceItem) itemerator.next();
        ItemPriceInfo priceInfo = commerceItem.getPriceInfo();
        if(priceInfo != null && !priceInfo.isOnSale()) 
        {
          RepositoryItem priceList = priceInfo.getPriceList();
          if(priceList != null)
            return priceList;
        }
      }
    }
    return null;
  }

  /**
   * Returns the sale price list from the order.
   * <p>
   * The price list from the first on sale commerce item in the order is returned.
   * with a price list associated.  
   * @param pOrder
   * @return price list item
   */
  public RepositoryItem getSalePriceListFromOrder(Order pOrder) 
  {
    //extract a price list from one of the order's items.
    if(pOrder.getCommerceItemCount() > 0) 
    {
      List items = pOrder.getCommerceItems();
      Iterator itemerator = items.iterator();
      while(itemerator.hasNext()) 
      {
        CommerceItem commerceItem = (CommerceItem) itemerator.next();
        ItemPriceInfo priceInfo = commerceItem.getPriceInfo();
        if(priceInfo != null && priceInfo.isOnSale()) 
        {
          RepositoryItem priceList = priceInfo.getPriceList();
          if(priceList != null)
            return priceList;
        }
      }
    }
    return null;
  }

  /**
   * Gets the locale for pricing.
   * If usePriceListLocale is true then it first obtains the price list to use and tries to use it's locale.
   * If price lists aren't in use, can't be obtained or has no locale then it will use the default locale
   * If the default locale isn't configured then the locale passed in is returned.
   * 
   * @param pProfile RepositoryItem profile 
   * @param pProfilePriceListPropertyName String name of the price list property in the profile
   * @param pUseDefaultPriceList boolean, true to use the default price list if needed
   * @param pExtraParameters Optional map of extra parameters which may include the price list
   * @param pLocale Locale to use if no price list or default locale is found
   * 
   * @return Locale to use for this pricing
   */
  public Locale getPricingLocale(RepositoryItem pProfile,                          
      String pPriceListPropertyName,      
      boolean pUseDefaultPriceList,
      Map pExtraParameters,
      Locale pLocale)
  {
    // Log entry
    if (isLoggingDebug()){
      logDebug("Entered getPricingLocale");
      logDebug("pProfile:" + pProfile);
      logDebug("pPriceListPropertyName:" + pPriceListPropertyName);
      logDebug("pUseDefaultPriceList:" + pUseDefaultPriceList);
      logDebug("pExtraParameters:" + pExtraParameters);
      logDebug("pLocale:" + pLocale);
    }

    // Local vars
    Locale locale = null;

    // First check price list if we should just use the passed in locale
    if (isUsePassedLocaleAsPricingLocale()){
      locale = pLocale;
      if (isLoggingDebug()){
        logDebug("isUsePassedLocaleAsPricingLocale:" + isUsePassedLocaleAsPricingLocale());
      }
    }
    else {
      // Get price list
      RepositoryItem priceList = null;
      try {
        priceList = getPriceList( pProfile, pPriceListPropertyName,
            pUseDefaultPriceList, pExtraParameters );
      }
      catch (PriceListException ple) {
        if (isLoggingWarning()){
          logWarning("Failed to get price list for locale.", ple);
        }
      }

      // Get locale from price list
      if (priceList != null){
        // Check price list for the locale
        PriceListManager priceListManager = getPriceListManager();
        if (priceListManager != null){
          locale = priceListManager.getPriceListLocale( priceList );
        }
        else if (isLoggingDebug()){  // Shouldn't happen since if priceListManager is null then so should price list
          logDebug("priceListManager not configured so couldn't get locale from price list.");
        }

        if (isLoggingDebug()){
          logDebug("price list locale:" + locale);
        }
      }
    }

    // If no locale from the price list then use default
    if (locale == null){
      locale = getDefaultLocale();
      if (isLoggingDebug()){
        logDebug("default locale:" + locale);
      }
    }

    // If still no locale then use the one passed in
    if (locale == null){
      locale = pLocale;
    }

    // Log exit
    if (isLoggingDebug()){
      logDebug("Leaving with locale:" + locale);
    }

    return locale;
  }

  /**
   * Gets the price list.  First checks the extra parameters and then checks the profile.
   * If the profile doesn't have a price list then it will optionally use the default price list.
   * This method requires the priceListManager property to be configured for this component otherwise
   * it will assume that price lists are not being used and return null.
   * 
   * @param pProfile RepositoryItem profile 
   * @param pPriceListPropertyName String name of the price list property in the profile
   * @param pUseDefaultPriceList boolean, true to use the default if one isn't found in the profile
   * @param pExtraParameters Optional map of extra parameters which may include the price list
   * 
   * @return RepositoryItem price list
   * @throws PriceListException
   */
  public RepositoryItem getPriceList(RepositoryItem pProfile,                                    
      String pPriceListPropertyName,
      boolean pUseDefaultPriceList,
      Map pExtraParameters)
  throws PriceListException
  {
    //  Log entry
    if (isLoggingDebug()){
      logDebug("Entered getPriceList");
      logDebug("pProfile:" + pProfile);
      logDebug("pPriceListPropertyName:" + pPriceListPropertyName);
      logDebug("pUseDefaultPriceList:" + pUseDefaultPriceList);
      logDebug("pExtraParameters:" + pExtraParameters);
    }

    // Local vars
    RepositoryItem priceList = null;
    PriceListManager priceListManager = null;

    // First check extra parameters. 
    priceList = getPriceListFromParameters( pExtraParameters, pPriceListPropertyName );

    // Now check profile
    if (priceList == null){   
      priceListManager = getPriceListManager();
      if (priceListManager != null){
        String priceListPropertyName = pPriceListPropertyName;
        if (priceListPropertyName == null){
          priceListPropertyName = priceListManager.getPriceListPropertyName();
        }
        if (priceListPropertyName != null){
          priceList = priceListManager.getPriceList( pProfile, priceListPropertyName, pUseDefaultPriceList );
        }
        else if (isLoggingDebug()){
          logDebug("No priceListPropertyName for priceListManager configured so can't get price list.");
        }
      }
      else if (isLoggingDebug()){
        logDebug("No priceListManager configured for PricingTools so assuming price lists not in use.");
      }
    }

    // Log exit
    if (isLoggingDebug()){
      logDebug("Leaving with priceList:" + priceList);
    }

    return priceList;
  }

  /**
   * Get the price list from the extra parameters.  
   * This should return null if you would rather use the price list out of the profile.  
   * This method looks up pExtraParameters map using the key either passed in if specified 
   * or by using the PriceListManager.priceListPropertyName property.  
   * 
   * If it is present, then the price list mapped to by that key is returned.  
   * If the value in the map is a String, then it is assumed that this is a price list id, 
   * and the PriceListManager is used to look up the price.
   * This method requires the priceListManager to be configured for this component otherwise it will
   * assume that price lists are not being used and return null.
   * Note: This method is called from ItemPriceCalculator.getDifferentPriceList()
   *
   * @param pExtraParameters Map of extra parameters to look up
   * @param pPriceListPropertyName String name of the price list in the extra parameters map, 
   * if null then PriceListManager.priceListPropertyName is used.
   * 
   * @return a priceList repositoryItem, or null if not found
   * @throws PriceListException
   **/
  public RepositoryItem getPriceListFromParameters(Map pExtraParameters, String pPriceListPropertyName)
  throws PriceListException
  {
    // Log entry
    if (isLoggingDebug()){
      logDebug("Entered getPriceListFromParameters");
      logDebug("pExtraParameters:" + pExtraParameters);
      logDebug("pPriceListPropertyName:" + pPriceListPropertyName);
    }

    // Local vars
    RepositoryItem priceList = null;
    String priceListPropertyName = pPriceListPropertyName;

    // Look in the extra parameters for the price list parameter
    if (pExtraParameters != null) {
      // Get price list manager
      PriceListManager priceListManager = getPriceListManager();
      if (priceListManager == null){
        if (isLoggingDebug()){
          logDebug("No priceListManager configured so can't get price list.");
        }
        return (null);
      }

      // Get price list property name
      if (priceListPropertyName == null){
        priceListPropertyName = priceListManager.getPriceListPropertyName();
      }

      if (priceListPropertyName == null){
        if (isLoggingDebug()){
          logDebug("No priceListPropertyName configured for priceListPropertyManager so can't get price list from map.");
        }
        return (null);
      }

      if (isLoggingDebug()){
        logDebug("priceListPropertyName:" + priceListPropertyName);
      }

      // Get price list from the parameters map
      Object extraPriceList = pExtraParameters.get(priceListPropertyName);
      if (extraPriceList != null){
        if (isLoggingDebug()){
          logDebug("Got the extra price list: " + extraPriceList);
        }

        // Check the extra param type and get a price list for it
        if (extraPriceList instanceof RepositoryItem){
          priceList = (RepositoryItem) extraPriceList;
        }
        else if (extraPriceList instanceof String) { 
          // assume it's an String id
          priceList = priceListManager.getPriceList((String)extraPriceList);
          if ((priceList == null) && (isLoggingWarning())){
            logWarning("The price list id (" + extraPriceList + ") in pExtraParameters was not valid.");
          }
        }
        else if(isLoggingWarning()){
          logWarning("Extra parameters contains a " + priceListPropertyName + 
          " that is not a string or a repository item. Ignoring.");
        }
      }
    }
    else if(isLoggingDebug()){
      logDebug("pExtraParameters is null.");
    }

    // Log exit
    if (isLoggingDebug()){
      logDebug("Leaving with priceList:" + priceList);
    }

    return priceList;
  }

  /**
   * Given a commerce item, loop through its detailed item price infos and
   * create the price beans.
   *
   * @param pItem
   *            The commerce item to generate beans for
   * @return list of beans with price infos
   */
  public List generatePriceBeans(CommerceItem pItem) {
    List beans = new ArrayList();

    // get the item price info
    ItemPriceInfo priceInfo = pItem.getPriceInfo();

    if (priceInfo != null) {
      List details = priceInfo.getCurrentPriceDetailsSorted();

      if (details != null) {
        beans = generatePriceBeans(details);
      }
    }

    return beans;
  }

  /**
   * Given a list of detailed item price infos, loop through each one and
   * create the price beans.
   *
   * @param pInfos
   *            The list of DetailedItemPriceInfo
   * @return list of beans with price infos
   */
  public List generatePriceBeans(List<DetailedItemPriceInfo> pInfos) {
    List beans = new ArrayList();
    if(pInfos != null) {
      for(DetailedItemPriceInfo dpi : pInfos) {
        addPriceBeanForInfo(dpi, beans);
      }
    }

    return beans;
  }
  
  
  /**
   * Given a DetailedItemPrice info, check the list of beans to see if one has
   * the same unit price and pricing model adjusters. If it does then just
   * increment the quantity of that bean. Otherwise create a new bean just for
   * it and add to the list
   *
   * @param pInfo
   *            The detailed item price info to get data from
   * @param pBeans
   *            List of UnitPriceBeans
   */
  protected void addPriceBeanForInfo(DetailedItemPriceInfo pInfo, List pBeans) {
    if (pInfo == null) {
      if (isLoggingError()) {
        logError("addPriceBeanForInfo was passed a null price info");
      }

      return;
    }

    // create a new UnitPriceBean for the info
    UnitPriceBean newBean = new UnitPriceBean(pInfo);

    if (isLoggingDebug()) {
      logDebug("Creating new bean for priceInfo\n info = " + pInfo + "\n bean = " + newBean);
    }

    newBean.setUnitPrice(round(newBean.getUnitPrice()));
    
    //Determine if bean should be split for rounding
    double leftovers = pInfo.getAmount() - newBean.getUnitPrice() * newBean.getQuantity();
    
    UnitPriceBean splitBean = null;
    
    if(leftovers != 0.0 && newBean.getQuantity() > 1) {
      double splitUnitPrice = round(newBean.getUnitPrice() + leftovers);
      
      if(splitUnitPrice != newBean.getUnitPrice()) {
        newBean.setQuantity(newBean.getQuantity() - 1);
      
        splitBean = new UnitPriceBean(pInfo);
        splitBean.setQuantity(1);
        splitBean.setUnitPrice(splitUnitPrice);
      }
    }
    
    // loop through the beans and see if any have the same price and
    // pricing models
    boolean beanMatch = false;
    boolean splitBeanMatch = false;
    
    int size = pBeans.size();
    UnitPriceBean upb = null;

    MATCHBEANS: 
      for (int k = 0; k < size; k++) {
        upb = (UnitPriceBean) pBeans.get(k);

        if (!beanMatch && upb.getUnitPrice() == newBean.getUnitPrice()) {
          // found a unit price match. see if the promotions match
          if ((upb.getPricingModels().size() == newBean.getPricingModels().size()) &&
              (upb.getPricingModels().containsAll(newBean.getPricingModels()))) {
            // definitely a match it has the same pricing models
            // update the quantity
            if (isLoggingDebug()) {
              logDebug("Found matching unit price bean; updating quantity");
            }

            upb.setQuantity(upb.getQuantity() + newBean.getQuantity());
            beanMatch = true;
          } // if the price detail matches pricing models with our dpi
        } // if the price detail unit price matches our unit price
        
        if (!splitBeanMatch && splitBean != null && upb.getUnitPrice() == splitBean.getUnitPrice()) {
          // found a unit price match. see if the promotions match
          if ((upb.getPricingModels().size() == splitBean.getPricingModels().size()) &&
              (upb.getPricingModels().containsAll(splitBean.getPricingModels()))) {
            // definitely a match it has the same pricing models
            // update the quantity
            if (isLoggingDebug()) {
              logDebug("Found matching unit price bean; updating quantity");
            }

            upb.setQuantity(upb.getQuantity() + splitBean.getQuantity());
            splitBeanMatch = true;
          } // if the price detail matches pricing models with our dpi
        } // if the price detail unit price matches our unit price
        
        if(splitBeanMatch && beanMatch) {
          break MATCHBEANS;
        }
      } // for each price beans

    // if no match then we need to add the new bean
    if (!beanMatch) {
      if (isLoggingDebug()) {
        logDebug("No matching bean found, adding bean to list bean=" + newBean);
      }

      pBeans.add(newBean);
    }
    
    if (!splitBeanMatch && splitBean != null) {
      if (isLoggingDebug()) {
        logDebug("No matching bean found, adding bean to list bean=" + splitBean);
      }

      pBeans.add(splitBean);
    }
  }
  
  /**
   * Instantiates a new ItemPriceSource object with the given parameters. 
   * @param pProductId the productid to which the source applies
   * @param pSkuId the skuid to which the source applies
   * @param pParentSkuId the parent sku id to which the source applies
   * @param pCommerceItemType the commerce item type to which the source applies
   * @param pCurrencyCode the currency to which the source applies. 
   * @return
   */
  public ItemPriceSource createItemPriceSource(String pProductId, String pSkuId, 
      String pParentSkuId, String pCommerceItemType, String pCurrencyCode)
  {
    return new ItemPriceSource(pProductId,pSkuId,pParentSkuId,pCommerceItemType,pCurrencyCode);
  }
  
  /**
   * Creates a new ItemPriceSource object based on the given item and parent
   * item. The product, sku, parent sku and commerce item type properties
   * will be set. 
   * 
   * @see #createItemPriceSource(String, String, String, String, String)
   * @param pCommerceItem
   * @param pParentCommerceItem
   * @param pCurrencyCode the currency for which the source object can apply
   * @return a new ItemPriceSource
   */
  public ItemPriceSource createItemPriceSource(CommerceItem pCommerceItem,
      CommerceItem pParentCommerceItem, String pCurrencyCode)
  {
    ItemPriceSource po;
    String productId = pCommerceItem.getAuxiliaryData().getProductRef() == null ? pCommerceItem.getAuxiliaryData().getProductId() : 
      ((RepositoryItem)pCommerceItem.getAuxiliaryData().getProductRef()).getRepositoryId();
    String skuId = pCommerceItem.getCatalogRefId();
    String commerceItemType = pCommerceItem.getCommerceItemClassType();
    String parentSkuId = pParentCommerceItem == null ? null : pParentCommerceItem.getCatalogRefId();
      
    po = createItemPriceSource(productId,skuId,parentSkuId,commerceItemType,pCurrencyCode);
    return po;
  }

  /**
   * Generates a List of <code>ItemPriceSource</code> objects based on the pricing information
   * contained in the given Order.
   * <p>
   * One <code>ItemPriceSource</code> is generated for each item in the order. Each configured
   * <code>ItemPriceSource<code> is called once for each <code>ItemPriceSource</code>
   * to populate it values.    
   * @param pExtraParameters Map of extra parameters that will passed through to the handlers
   * that generate the source objects. 
   */
  public List generateItemPriceSources(Order pOrder, Map pExtraParameters)
  {
    Map params;
    if(pExtraParameters != null)
      params = pExtraParameters;
    else
      params = new HashMap();
      
    String currencyCode = pOrder.getPriceInfo().getCurrencyCode();
    
    List priceSources = new ArrayList();
    Collection commerceItems = pOrder.getCommerceItems();
    Iterator commerceItemerator = commerceItems.iterator();
    CommerceItem item;
    
    while(commerceItemerator.hasNext())
    {
      item = (CommerceItem)commerceItemerator.next();
      generateItemPriceSources(priceSources,pOrder,item,null,currencyCode, params);
    }
    return priceSources;
  }
  
  /**
   * Creates a new ItemPriceSource object and calls each handler to populate
   * its values. 
   * @param pItemPriceSources the current list of source objects. the new source object will be appended to this List
   * @param pOrder the order that contains the commerce item
   * @param pCommerceItem the commerce item from which the source object will be created
   * @param pParentCommerceItem the parent commerce item of pCommerceItem. this can be null
   * @param pCurrencyCode
   * @param pExtraParameters
   */
  protected void generateItemPriceSources(List pItemPriceSources, Order pOrder, 
      CommerceItem pCommerceItem, 
      CommerceItem pParentCommerceItem,
      String pCurrencyCode, Map pExtraParameters)
  {
    
    //if either the item or parent item are marked as final, skip them. 
    if(pCommerceItem.getPriceInfo() != null && pCommerceItem.getPriceInfo().isAmountIsFinal())
      return;
    
    if(pParentCommerceItem != null && pParentCommerceItem.getPriceInfo() != null && pParentCommerceItem.getPriceInfo().isAmountIsFinal())
      return;
    
    ItemPriceSourceHandler[] itemPriceSourceHandlers = getItemPriceSourceHandlers();
    
    ItemPriceSource ps = createItemPriceSource(pCommerceItem,pParentCommerceItem, pCurrencyCode);
    
    
    if(itemPriceSourceHandlers !=null)
    {
      boolean contributors=false;
      for(int i =0;i< itemPriceSourceHandlers.length;i++)
      {
        if(itemPriceSourceHandlers[i].populateItemPriceSource(ps, pOrder, pCommerceItem, pParentCommerceItem, pExtraParameters))
          contributors=true;
      }

      if(contributors)
        pItemPriceSources.add(ps);
    
      if(pCommerceItem instanceof CommerceItemContainer)
      {
        CommerceItemContainer container = (CommerceItemContainer)pCommerceItem;
        List containedItems= container.getCommerceItems();
        Iterator containedItemserator = containedItems.iterator();
        CommerceItem containedItem;
        while(containedItemserator.hasNext())
        {
          containedItem = (CommerceItem)containedItemserator.next();
          generateItemPriceSources(pItemPriceSources,pOrder,containedItem,pCommerceItem,pCurrencyCode, pExtraParameters);
        }
      }
    }
  }
  
  /**
   * Maps the <code>CommerceItems</code> to the <code>ItemPriceSource</code> objects
   * <p>
   * This method is called by the ItemPricingEngine to map a List of source objects to the
   * items being priced in the current pricing operation. 
   * <p>
   * If a <code>CommerceItem</code> is a <code>CommerceItemContainer</code> this
   * method is recursive in order to match the contained items as well. 
   * 
   * @param pItemPriceSources the ItemPriceSource objects to match with the items.
   * @param pCommerceItems the CommerceItems to match
   * @param pParentCommerceItem optional parent commerce item that contains
   * the list of commerce items. If not null, the parent sku must match
   * the parent sku in the override.  
   * @param pCurrencyCode the currency code of the current pricing operation. This
   * currency must match the currency code in the ItemPriceSource for it to be mapped to an
   * item. 
   * @return Map of commerce item id to <code>ItemPriceSource</code>
   */
  public Map generateItemPricingSourceMap(List pItemPriceSources, 
      List pCommerceItems, CommerceItem pParentCommerceItem, String pCurrencyCode)
  {
    if(isLoggingDebug())
      logDebug("generateItemPricingSourceMap: started");
    Map itemToPriceSource= new HashMap();
    Iterator commerceItems = pCommerceItems.iterator();
    CommerceItem commerceItem;
    ItemPriceSource po;
    while(commerceItems.hasNext())
    {
      commerceItem = (CommerceItem)commerceItems.next();
      po = findMatchingSource(pItemPriceSources,commerceItem,pParentCommerceItem, pCurrencyCode);
      if(po != null)
      {
        if(isLoggingDebug())
        {
          logDebug("generateItemPricingSourceMap: ItemPriceSource matched to item");
          logDebug("ItemPriceSource: " + po + ", CommerceItem: " + commerceItem);
        }
        itemToPriceSource.put(commerceItem.getId(),po);
      }
      
      if(commerceItem instanceof CommerceItemContainer)
      {
        CommerceItemContainer container = (CommerceItemContainer)commerceItem;
        List containedItems= container.getCommerceItems();
        Map overideMap = generateItemPricingSourceMap(pItemPriceSources,containedItems,commerceItem, pCurrencyCode);
        itemToPriceSource.putAll(overideMap);
      }
    }
    if(isLoggingDebug())
      logDebug("generateItemPricingSourceMap: ended");
    return itemToPriceSource;
  }

  /**
   * Iterates over the collection of ItemPriceSource objects and returns the first one that matches
   * the given item and parent item combination
   * @see ItemPriceSource#isItemMatch(CommerceItem, CommerceItem)
   * @param pItemPriceSource
   * @param pCommerceItem
   * @param pParentCommerceItem
   * @param pCurrencyCode if provided the currency code must be the same for a successful match
   * @return the ItemPriceSource object that matches
   */
  public ItemPriceSource findMatchingSource(Collection pItemPriceSource, CommerceItem pCommerceItem, CommerceItem pParentCommerceItem, String pCurrencyCode)
  {
    ItemPriceSource source = null;
    Iterator sourcerator = pItemPriceSource.iterator();
    while(sourcerator.hasNext())
    {
      source = (ItemPriceSource)sourcerator.next();
      if(source.isItemMatch(pCommerceItem,pParentCommerceItem))
      {
        //if also matching current code then make sure it matches. 
        if(pCurrencyCode == null || pCurrencyCode.equals(source.getCurrencyCode()) )
          return source;
      }
    }
    return null;
  }
  
  /**
   * This method returns the <code>ItemPriceSource</code> mapped to the commerce item
   * id in the pricing overide Map stored in the extra parameters. 
   * <p>
   * Calculators use this method to determine if an ItemPriceSource was passed into the
   * pricing operation through the extra parameters. 
   * 
   * @see PricingConstants#ITEM_PRICE_SOURCE_MAP_PARAM 
   * @param pItem the <code>CommerceItem</code> for which a ItemPriceSource should be returned
   * @param pExtraParams the pricing operations extra parameters Map
   * @return ItemPriceSource that matches the CommerceItem
   */
  public ItemPriceSource getItemPriceSource(ItemPriceInfo pPriceQuote, CommerceItem pItem, RepositoryItem pPricingModel, Locale pLocale, RepositoryItem pProfile, Map pExtraParameters)
  {
    if(isLoggingDebug())
      logDebug("getItemPriceSource: started");
    ItemPriceSource ps = null;
    
    if(pExtraParameters != null)
    {
      Map priceSourceMap = (Map) pExtraParameters.get(atg.commerce.pricing.PricingConstants.ITEM_PRICE_SOURCE_MAP_PARAM);
      if(priceSourceMap != null && priceSourceMap.containsKey(pItem.getId()))
        ps = (ItemPriceSource)priceSourceMap.get(pItem.getId());
      if(isLoggingDebug())
        logDebug("getItemPriceSource: ItemPriceSource found: " + ps);
      if(isLoggingDebug())
        logDebug("getItemPriceSource: ended");
    }
    return ps;
  }
  /**
   * Returns all the <code>PricingAdjustments</code> found in
   * the price info's <code>adjustments</code> property whose description
   * matches the given description  
   * @param pItemPriceInfo the price info containing the adjustments. 
   * @param pDescription the description to match
   * @return a list of adjustments that match
   */
  public List findAdjustmentsByDescription(ItemPriceInfo pItemPriceInfo, String pDescription)
  {
    if(isLoggingDebug())
      logDebug("findAdjustmentsByDescription started with description: " + pDescription);
    
    if(pDescription == null)
      return null;
    
    List returnAdjustments = new ArrayList();
    List adjustments = pItemPriceInfo.getAdjustments();
    if(adjustments != null)
    {
      PricingAdjustment pa;
      Iterator adjustmenterator = adjustments.iterator();
      while(adjustmenterator.hasNext())
      {
        pa = (PricingAdjustment)adjustmenterator.next();
        if(pDescription.equals(pa.getAdjustmentDescription()))
          returnAdjustments.add(pa);
      }
    }
    if(isLoggingDebug())
      logDebug("findAdjustmentsByDescription adjustments returned: " + returnAdjustments);
    
    if(isLoggingDebug())
      logDebug("findAdjustmentsByDescription ended");
    return returnAdjustments;
  }
  
  /**
   * Returns the total quantity of the items in the List that match the
   * given pItem.
   * <p>
   * This method is used by the bulk pricing calculators to aggregate quantity
   * for matching items so the correct level is used across the items.  
   *
   * @see #isMatchForBulkPricing(CommerceItem, CommerceItem)   
   * @param pItems
   * @param pItem
   * @return the total quantity
   */
  public long getTotalQuantityForBulkPricing(List pItems, CommerceItem pItem)
  {
    Iterator itemerator = pItems.iterator();
    long quantity =0;
    CommerceItem item;
    while(itemerator.hasNext())
    {
      item = (CommerceItem)itemerator.next();
      if(isMatchForBulkPricing(item,pItem))
        quantity += item.getQuantity();
    }
    return quantity;
  }

  /**
   * determines if the two items should be considered a match for aggregating quantity
   * @see #getTotalQuantityForBulkPricing(List, CommerceItem)
   * <p>
   * By default, the product id and sku id must be equal to be considered a match. 
   * @param pItem1
   * @param pItem2
   * @return true if considered a match
   */
  protected boolean isMatchForBulkPricing(CommerceItem pItem1, CommerceItem pItem2)
  {
    if (pItem1.getAuxiliaryData().getProductId() != pItem2.getAuxiliaryData().getProductId() &&
        (pItem1.getAuxiliaryData().getProductId() == null ||
            pItem2.getAuxiliaryData().getProductId() == null ||
         !pItem1.getAuxiliaryData().getProductId().equals (pItem2.getAuxiliaryData().getProductId()))) 
      return false;
    
    if (pItem1.getCatalogRefId() != pItem2.getCatalogRefId() &&
        (pItem1.getCatalogRefId() == null ||
            pItem2.getCatalogRefId() == null ||
         !pItem1.getCatalogRefId().equals (pItem2.getCatalogRefId()))) 
      return false;
    return true;
    
  }
  
  /**
   * Called by the tiered pricing calculators to generate the key used to store the 
   * quantity info about an Item processed during the pricing operation.
   * <p> 
   * This quantity info is used to maintain tier levels across multiple items that reference the
   * same product/sku combination. By default the key returned is a String concat of the product id and
   * sku id. 
   * 
   * @param pItem
   * @return Object key
   */
  public Object generateKeyForTieredProcessedItem(CommerceItem pItem)
  {
    String key;
    key = pItem.getAuxiliaryData().getProductId() == null ? "null" : pItem.getAuxiliaryData().getProductId() + "-" + pItem.getCatalogRefId();  
    return key;
  }

} // end of class
