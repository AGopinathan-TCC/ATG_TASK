/*<ATGCOPYRIGHT>
 * Copyright (C) 1997-2011 Art Technology Group, Inc.
 * All Rights Reserved.  No use, copying or distribution of this
 * work may be made except in accordance with a valid license
 * agreement from Art Technology Group.  This notice must be
 * included on all copies, modifications and derivatives of this
 * work.
 *
 * Art Technology Group (ATG) MAKES NO REPRESENTATIONS OR WARRANTIES
 * ABOUT THE SUITABILITY OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. ATG SHALL NOT BE
 * LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING,
 * MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
 *
 * "Dynamo" is a trademark of Art Technology Group, Inc.
 </ATGCOPYRIGHT>*/

package atg.servlet.pipeline;

import javax.servlet.Servlet;
import atg.nucleus.*;
import atg.servlet.*;

import java.io.*;
import java.util.*;
import javax.servlet.http.*;
import javax.servlet.*;

/**
 * This is a pipeline servlet that can be used to record requests made to
 * a file in a form suitable for playback with URLHammer.  All requests
 * that are received by this servlet are output to the value of the
 * recordFile if the recording property is true.
 * <p>
 * To add this servlet to your pipeline, you need to make sure that
 * an instance of the RecordingServlet is in your servlet pipeline.  By
 * default, there is a .properties for a RecordingServlet, but this component
 * is not created when the system starts up.  It can be created and inserted
 * into the pipeline by typing in the URL for this servlet in the admin
 * UI.  For example, you just enter in the URL:
 * <pre>http://localhost:8830/nucleus/atg/dynamo/servlet/pipeline/RecordingServlet</pre>
 * <p>
 * You can avoid this step by adding the RecordingServlet to the Initial.properties
 * file so that it is created automatically when nucleus starts up.
 * <p>
 * If you'd like to add your own RecordingServlet into the servlet pipeline,
 * follow these steps:
 * <ul>
 * <li>Add a .properties file that maps this servlet into a nucleus component
 * <li>set the insertAfterServlet property to something like
 * <pre>/atg/dynamo/servlet/pipeline/FileFinderServlet</pre>
 * <li>Add this servlet to an Initial.properties file so that it gets
 * created when the system starts up
 * </ul>
 * For example, here is a sample .properties file:
 * <pre>
 * $class=atg.servlet.pipeline.RecordingServlet
 * insertAfterServlet=FileFinderServlet
 * recordFile=c:/temp/recordFile
 * recording=true
 * </pre>
 *
 * <p>You can stop recording this session and begin recording another one
 * by toggling the value of the "recording" property.  Note that this
 * the old record file is currently truncated when the value is turned on and
 * off.  RecordingServlet will record more than one session at the same
 * time - each URL is tagged with the session that generated that request.
 * When a script with multiple sessions is replayed, each thread replays
 * the requests generated by one session at a time.
 *
 * <p>To replay a file recorded with this servlet, run:
 * <pre>java atg.core.net.URLHammer -server &lt;server:port&gt; -script &lt;recordFile&gt; &lt;nthreads&gt; &lt;ntimes&gt;</pre>
 *
 * <p>The recorded request sequence will be replayed once for each of nthreads
 * and the entire sequence is replayed ntimes.  The starting time for each
 * thread is staggered so that the requests are not lock-step.  If you
 * do not specify the -cookies option to URLHammer, the cookies are flushed
 * after each execution of the request.  Thus each execution of the script
 * will use a new session unless you use -cookies.
 *
 * <p>Use the -nopause option
 * to replay the requests as fast as possible rather than replaying them
 * at the same speed in which they were recorded.
 *
 * @see InsertableServletImpl
 * @author Jeff Vroom
 * @version $Id: //product/DAS/version/10.0.3/Java/atg/servlet/pipeline/RecordingServlet.java#2 $$Change: 651448 $
 * @updated $DateTime: 2011/06/07 13:55:45 $$Author: rbarbier $
 * @beaninfo
 *   description: Records requests in a form suitable for playback by URLHammer
 *   attribute: functionalComponentCategory Services
 *   attribute: featureComponentCategory Pipeline
 *   attribute: icon /atg/ui/common/images/pipelinecomp.gif
 **/

public
class RecordingServlet
extends InsertableServletImpl
{
  //-------------------------------------
  /** Class version string */

  public static String CLASS_VERSION =
  "$Id: //product/DAS/version/10.0.3/Java/atg/servlet/pipeline/RecordingServlet.java#2 $$Change: 651448 $";


  //--------------------------------------
  // Properties


  /**
   * The file to record info into
   */
  File mRecordFile = null;
  
  /**
   * @beaninfo
   *   description: The file to record into
   */
  public synchronized File getRecordFile() {
    return mRecordFile;
  }
  public synchronized void setRecordFile(File pFile) {
    mRecordFile = pFile;

    if (mOutputWriter != null) {
      mOutputWriter.close();
      mOutputWriter = null;
    }
  }
  
  /**
   * The directory to record keep test files in if we're saving responses
   */
  File mTestFilesDirectory = null;
  

  /**
   * @beaninfo
   *   description: The directory to keep test files in
   */
  public synchronized File getTestFilesDirectory() {
    return mTestFilesDirectory;
  }
  public synchronized void setTestFilesDirectory(File pDir) {
    mTestFilesDirectory = pDir;
  }

  /**
   * If we are in the middle of recording a file, the current output writer
   */
  PrintWriter mOutputWriter = null;
  long mLastTime;
  
  /**
   * Are we recording now or not?
   */
  boolean mRecording = false;

  /**
   * @beaninfo
   *   description: True if we are recording now
   */
  public synchronized boolean getRecording() {
    return mRecording;
  }
  public synchronized void setRecording(boolean pRecording) {
    mRecording = pRecording;

    if (!mRecording && mOutputWriter != null) {
      mOutputWriter.close();
      mOutputWriter = null;
    }
  }
  
   /**
   * Are we saving responses for testing or not?
   */
  boolean mSavingResponses = false;

  /**
   * @beaninfo
   *   description: True if we are saving responses for testing purposes now
   */
  public synchronized boolean getSavingResponses() {
    return mSavingResponses;
  }
  public synchronized void setSavingResponses(boolean pSavingResponses) {
    mSavingResponses = pSavingResponses;
  }

  /**
   * Are we keeping stats now or not?
   */
  boolean mKeepingStatistics = false;
  /**
   * @beaninfo
   *   description: True if we are keeping statistics about what we
   *                record
   */
  public synchronized boolean getKeepingStatistics() {
    return mKeepingStatistics;
  }
  public synchronized void setKeepingStatistics(boolean pKeepingStatistics) {
    mKeepingStatistics = pKeepingStatistics;
    /* Tie together these two properties */
    mTracingMemory = pKeepingStatistics;
  }

  /**
   * @beaninfo
   *   description: Timing statistics that we've accumulated
   */
  Dictionary mStatistics = new Hashtable();
  public synchronized Dictionary getStatistics() {
    return mStatistics;
  }

  //--------- Property: TracingMemory -----------
  boolean mTracingMemory = false;
  /**
   * Sets the property TracingMemory.
   */
  public void setTracingMemory(boolean pTracingMemory) {
    mTracingMemory = pTracingMemory;
  }
  /**
   * @beaninfo
   *   description: True if we are tracing memory usage of each request.
   */
  public boolean getTracingMemory() {
    return mTracingMemory;
  }

  int mNumActiveRequests = 0;
  int mResponseNum = 0;

  /**
   * The number of currently active requests (if memory tracing is enabled).
   */
  public int getNumActiveRequests() {
    return mNumActiveRequests;
  }

  boolean mTracingNow = false;

  /**
   * Are we currently tracing a request now?
   */
  public boolean getTracingNow() {
    return mTracingNow;
  }

  //-------------------------------------
  /**
   * Services a DynamoHttpServletRequest/Response pair
   * @exception ServletException if an error occurred while processing
   * the servlet request
   * @exception IOException if an error occurred while reading or writing
   * the servlet request
   **/
  public void service (DynamoHttpServletRequest pRequest,
                       DynamoHttpServletResponse pResponse)
       throws IOException, ServletException
  {
    long startTime = 0;
    boolean keepingStats = false;
    boolean noException = false;
    boolean tracingThisRequest = false;
    /* Get this up front in case it changes while we're handling this request * */
    boolean tracingMemory = mTracingMemory;
    /*
     * Get the url before the request goes down the pipeline.
     * This way, if someone munges the path info in the pipeline,
     * we'll get the original version.
     */
    String url = pRequest.getRequestURI();
    if (mKeepingStatistics || tracingMemory) {
      startTime = System.currentTimeMillis();
      keepingStats = true;
    }

    long beginMemory = 0, endMemory = 0;

    if (tracingMemory) {
      synchronized(this) {
        /*
   * If we are not already tracing and we are the only thread
   * executing a request right now, let's try to figure out how much
   * memory this request is going to take.
   */
        if (!mTracingNow && mNumActiveRequests == 0) {
    mTracingNow = true;
    tracingThisRequest = true;
  }
  /* Cancel the current trace cause we're about to mess it up */
  else mTracingNow = false;

  /* Keep track of the # of active requests */
  mNumActiveRequests++;
      }
      /* Let's give it a try... */
      if (tracingThisRequest) {
        beginMemory = Runtime.getRuntime().freeMemory();
      }
    }
    
    // If we want to save the contents of responses for testing purposes, 
    // we'll need to both capture the output and send it to the original 
    // output stream. This is what a CachingServletOutputStream does...
    CachingServletOutputStream stream = null;
    LazyCachingPrintWriter writer = null;

    if (mSavingResponses){
      stream = new CachingServletOutputStream(pResponse.getOutputStream(), true);
      writer = new LazyCachingPrintWriter(pResponse.getResponse());
      pResponse.setOutputStream(stream);
      pResponse.setWriter(writer);
    }
    try {
      super.service(pRequest, pResponse);
      noException = true;
    }
    finally {
      if (tracingMemory) {
        synchronized (this) {
    mNumActiveRequests--;
    if (tracingThisRequest && mTracingNow && mNumActiveRequests == 0) {
            endMemory = Runtime.getRuntime().freeMemory();
      /* A GC happened while we were running */
      if (endMemory > beginMemory) tracingThisRequest = false;
    }
    else tracingThisRequest = false;
    mTracingNow = false;
  }
      }
      if (keepingStats) {
  long endTime = System.currentTimeMillis();
  long time = endTime - startTime;

  if (url != null) {
    synchronized (this) {
      StatInfo info = (StatInfo) mStatistics.get(url);
      if (info == null) {
        info = new StatInfo();
        mStatistics.put(url, info);
      }
      synchronized (info) {
        info.numRequests++;
        info.totalTime += time;
        if (time < info.minTime)
    info.minTime = time;
        if (time > info.maxTime) {
    info.maxTime = time;
    info.maxQueryString = pRequest.getQueryString();
        }
        if (!noException)
          info.exceptions++;
        if (tracingThisRequest) {
          int memoryUsed = (int) (beginMemory - endMemory);
          info.numMemoryRequestsTraced++;
    info.totalMemoryUsed += memoryUsed;
          if (memoryUsed < info.minMemoryUsed)
      info.minMemoryUsed = memoryUsed;
    if (memoryUsed > info.maxMemoryUsed)
      info.maxMemoryUsed = memoryUsed;
        }
      }
    }
  }
      }

      if (mRecording) {
  if (mOutputWriter == null) {
    synchronized (this) {
      if (mOutputWriter == null) {
        try {
    mOutputWriter = new PrintWriter(new FileOutputStream(mRecordFile));
    mLastTime = System.currentTimeMillis();
        }
        catch (IOException e) {
    if (isLoggingError())
      logError("Unable to open recording file: " + mRecordFile);
        }
      }
    }
  }
  if (mOutputWriter != null) {
    HttpSession session = pRequest.getSession(true);
    String sessionId;
    if (session != null) sessionId = session.getId();
    else sessionId = "missingSession";

    synchronized (this) {
      /*
       * Output the path name of the request relative to the server
       * that is being used.
       */
      /*
      if (pRequest.getContextPath() != null)
        mOutputWriter.print(pRequest.getContextPath());        
      if (pRequest.getServletPath() != null)
        mOutputWriter.print(pRequest.getServletPath());
      if (pRequest.getPathInfo() != null)
        mOutputWriter.print(pRequest.getPathInfo());
      */
      mOutputWriter.print(url);
      String urlargs = pRequest.getURLParameterString();
      if (urlargs != null && urlargs.length() > 0) {
        mOutputWriter.print(';');
        mOutputWriter.print(urlargs);
      }
      String query = pRequest.getQueryString();
      if(query == null){
        if(pRequest.getRequest() != null){
          query = pRequest.getRequest().getQueryString();
        }
      }
      if (query != null && query.length() > 0) {
        mOutputWriter.print('?');
        mOutputWriter.print(query);
      }
      mOutputWriter.print(' ');
      long newTime = System.currentTimeMillis();
      mOutputWriter.print(newTime - mLastTime);
      mLastTime = newTime;
      if (pRequest.getMethod().equalsIgnoreCase("POST")) {
        Enumeration e;
        int ct = 0;
        for (e = pRequest.getPostParameterNames(); e.hasMoreElements();) {
          String key = (String) e.nextElement();
          String [] vals = pRequest.getPostParameterValues(key);
          if (vals == null)
            ct++;
          else
            ct += vals.length;
        }
        mOutputWriter.print(' ');
        mOutputWriter.print(ct);
        mOutputWriter.print(' ');
        mOutputWriter.println(sessionId);
       for (e = pRequest.getPostParameterNames(); e.hasMoreElements();) {
         String key = (String) e.nextElement();
         String [] vals = pRequest.getPostParameterValues(key);
         if ( vals == null) mOutputWriter.println(key+"=");
         else {
           for ( int i = 0; i < vals.length; i++) {
             mOutputWriter.print(key);
             mOutputWriter.print('=');
             mOutputWriter.println(vals[i]);
           }
         }
       }
      }
      else {
        mOutputWriter.print(" -1 ");
        mOutputWriter.println(sessionId);
      }
      mOutputWriter.flush();
    }    
  }
    
  if( mSavingResponses )  {
    String fileName = null;
    
    try {
      File outFile = null;      
      fileName = Integer.toString(mResponseNum) + ".out"; 
          
      if ( mTestFilesDirectory == null ){
        String path = new String(mRecordFile.getAbsolutePath() ); 
        // Find the index of the last character which is not a slash.
        int k = path.length() - 1;
        while (path.charAt(k) == '/' || path.charAt(k) == File.separatorChar)
          k--;
        // Skip the file name  
        while (path.charAt(k) != '/' && path.charAt(k) != File.separatorChar)
          k--;  
        path = path.substring(0, k + 1).concat("testFiles");
        mTestFilesDirectory = new File(path);
      }
      
      if( mTestFilesDirectory != null && !mTestFilesDirectory.exists() )
          mTestFilesDirectory.mkdir();                
      
      outFile = new File(mTestFilesDirectory, fileName);
      OutputStream outStream = new FileOutputStream(outFile);
      if(writer.getContainedArrayWriter()!=null
          && writer.getContainedArrayWriter().size() > 0){
        OutputStreamWriter out = new OutputStreamWriter(outStream,pResponse.getCharacterEncoding());
        char[] respn = writer.getContainedArrayWriter().toCharArray();
        out.write(respn);
        out.flush();
        out.close();
      }
      else if(stream.toByteArray() != null && stream.toByteArray().length > 0){
        byte content[] = stream.toByteArray();
        outStream.write(content);
        outStream.close();
      }
      else{
        logError("Unable to write the Response to File since either no ouput was generated " +
                     "or the Writer has Changed... ");
      }
      mResponseNum++;
    }
    catch (IOException e) {
      if (isLoggingError())
        logError("Unable to open out file... " + mTestFilesDirectory 
                                               + File.separatorChar 
                                               + fileName);
    }
  }
      }
    }
  }

  /**
   *
   * Creates and returns a new Servlet that will administer this
   * service.  By default, this creates a ServiceAdminServlet, but
   * subclasses may create their own servlets.
   **/
  protected Servlet createAdminServlet ()
  {
    return new RecordingServletAdminServlet(this, getNucleus());
  }

  /**
   * @beaninfo
   *   description: Clears statistics that have been accumulated
   */
  public synchronized void clearStatistics() {
    mStatistics = new Hashtable();
  }

  class StatInfo {
    long minTime = 100000000;
    long maxTime = 0;
    int numRequests = 0;
    long totalTime = 0;
    int exceptions = 0;
    String maxQueryString = null;

    int minMemoryUsed = 100000000;
    int maxMemoryUsed = 0;
    int totalMemoryUsed = 0;
    int numMemoryRequestsTraced = 0;

    public String toString() {
      long avgTimeMillis = totalTime / numRequests;
      double avgTimeSecs = avgTimeMillis / 1000.0;
      return "min=" + minTime + " max=" + maxTime + " avg=" +
        avgTimeSecs + " num=" + numRequests + " exceptions=" + exceptions;
    }
  }

  class RecordingServletAdminServlet extends PipelineableServletAdminServlet {
    private static final long serialVersionUID = 1L;


    public RecordingServletAdminServlet (PipelineableServlet pService,
                                          Nucleus pNucleus) {
      super (pService, pNucleus);
    }


    protected void printAdmin (HttpServletRequest pRequest,
                               HttpServletResponse pResponse,
                               ServletOutputStream pOut)
         throws ServletException, IOException
    {
      if (mService instanceof RecordingServlet) {
        boolean first = true;
  boolean hasMemoryTraces = false;
        Dictionary statistics = ((RecordingServlet) mService).getStatistics();
        pOut.println("<h2>Time for each URL (in seconds)</h2>");
        for (Enumeration e = statistics.keys(); e.hasMoreElements(); ) {
          if (first) {
            first = false;
            pOut.println("<table border><tr><td>URL</td><td># requests</td><td>avg</td><td>min</td><td>max</td><td># excepts.</td><td>query String of max request</td></tr>");
          }
          String key = (String) e.nextElement();
          StatInfo info = (StatInfo) statistics.get(key);
          long avgTimeMillis = info.totalTime / info.numRequests;
          double avgTimeSecs = avgTimeMillis / 1000.0;
          pOut.print("<tr><td>");
          pOut.print(key);
          pOut.print("</td><td>");
          pOut.print(info.numRequests);
          pOut.print("</td><td>");
          pOut.print(avgTimeSecs);
          pOut.print("</td><td>");
          pOut.print(info.minTime/1000.0);
          pOut.print("</td><td>");
          pOut.print(info.maxTime/1000.0);
          pOut.print("</td><td>");
          pOut.print(info.exceptions);
          pOut.print("</td><td>");
    pOut.print(info.maxQueryString != null ? info.maxQueryString : "");
          pOut.println("</td></tr>");
    if (info.numMemoryRequestsTraced > 0)
      hasMemoryTraces = true;
        }
        if (!first)
          pOut.println("</table>");
        else if (!mKeepingStatistics)
          pOut.println("No statistics available - select the keepingStatistics property below and change its value to true to record information about each URL");
        else
          pOut.println("No URLs requested yet");
  if (hasMemoryTraces) {
    pOut.println("<h2>Memory for each URL (in bytes)</h2>");
    pOut.println("<table border><tr><td>URL</td><td># requests</td><td>avg</td><td>min</td><td>max</td></tr>");
    for (Enumeration e = statistics.keys(); e.hasMoreElements(); ) {
      String key = (String) e.nextElement();
      StatInfo info = (StatInfo) statistics.get(key);
      if (info.numMemoryRequestsTraced != 0) {
        long avgBytes = info.totalMemoryUsed / info.numMemoryRequestsTraced;
        pOut.print("<tr><td>");
        pOut.print(key);
        pOut.print("</td><td>");
        pOut.print(info.numMemoryRequestsTraced);
        pOut.print("</td><td>");
        pOut.print(avgBytes);
        pOut.print("</td><td>");
        pOut.print(info.minMemoryUsed);
        pOut.print("</td><td>");
        pOut.print(info.maxMemoryUsed);
        pOut.println("</td></tr>");
      }
    }
    pOut.println("</table>");
    pOut.println("<p>Note: these numbers do not account for memory used by non request related activity in your VM such as scheduled operations.");
  }
  else if (!mTracingMemory) {
    pOut.println("<p>Memory usage tracing disabled.  Set the tracingMemory property to true to trace memory for each request.  ");
    pOut.println("This option only records requests that run through the server one at a time.");
  }
        if (!mRecording) {
          pOut.println("<p>Set the recording property to true to record requests for playback with atg.core.net.URLHammer");
        }
      }

      super.printAdmin (pRequest, pResponse, pOut);
    }
  }
}
