/*<ATGCOPYRIGHT>
 * Copyright (C) 1997-2011 Art Technology Group, Inc.
 * All Rights Reserved.  No use, copying or distribution of this
 * work may be made except in accordance with a valid license
 * agreement from Art Technology Group.  This notice must be
 * included on all copies, modifications and derivatives of this
 * work.
 *
 * Art Technology Group (ATG) MAKES NO REPRESENTATIONS OR WARRANTIES
 * ABOUT THE SUITABILITY OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. ATG SHALL NOT BE
 * LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING,
 * MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
 *
 * "Dynamo" is a trademark of Art Technology Group, Inc.
 </ATGCOPYRIGHT>*/

package atg.integrations.cybersource;

import atg.payment.Message;
import atg.nucleus.*;

import java.io.*;
import java.net.*;
import java.util.*;
import java.text.DecimalFormat;

import com.cybersource.ics.client.*;
import com.cybersource.ics.client.message.*;
import com.cybersource.ics.base.exception.*;
import com.cybersource.ics.base.message.*;

/**
 *
 * <p>This class manages the communication to the CyberSource server.
 *  All CyberSource integration services use this class to connect to the server.
 *
 * <p>All information on the CyberSource API was aquired from
 * 19991112_ICS2_DG.pdf  version 2.
 *
 * @author Commerce product development team.
 * @version $Id: //product/DCS/version/10.0.3/Java/atg/integrations/cybersource/CyberSourceConnection.java#2 $$Change: 651448 $
 * @updated $DateTime: 2011/06/07 13:55:45 $$Author: rbarbier $
 **/

public class CyberSourceConnection extends GenericService
{
    //-------------------------------------
    // Class version string
    
    public static String CLASS_VERSION = "$Id: //product/DCS/version/10.0.3/Java/atg/integrations/cybersource/CyberSourceConnection.java#2 $$Change: 651448 $";
    public static final String mResourceBundle = "atg.integrations.cybersource.MessageResource";
    
    /**
     * Default constructor for the CyberSource connection object.
     * @beaninfo hidden: false
     **/
  
    public CyberSourceConnection () {
    }

    private boolean isInitialized;
    
    /**
     * Return true if this connection has been initialized and is ready for use.
     * @beaninfo hidden: false
     **/
  
    public boolean getInitialized() {
        return isInitialized;
    }
    
    /**
     * A message object used to format localized error messages.
     * @beaninfo hidden: false
     **/
  
    public static Message msg = new Message(mResourceBundle);

    public String mCsConfigFile = null;
    
    /**
     * Specify the path to the ICSClient.props file that contains name=value
     * client & server pair info to communicate with CyberSource payment
     * system.  Initially it contains test keys and certificates for
     * testing.  After running the ECert application, these values should be
     * replaced with keys and certificates generated by ECert program.
     * @beaninfo hidden: false
     **/
    
    public void setCsConfigFile(String pCsConfigFile) {
        mCsConfigFile = pCsConfigFile;
    }
    
    /**
     * Get the path to the ICSClient.props file used to configure
     * communication with the CyberSource payment system.
     * @beaninfo hidden: false
     **/
  
    public String getCsConfigFile() {
        return mCsConfigFile;
    }
    

  String mMerchantId = null;
    
    /**
     * Get the CyberSource merchant ID to use with this connection.
     * @beaninfo hidden: false
     **/
  
    public String getMerchantId() {
        return mMerchantId;
    }
    
    private String mMerchantIdPropertyName;

    /**
     * Specify the name of the property from the ICSClient.props file that
     * specifies the MerchantId to use.  This property is used only for
     * 3210 version, all the later versions obtain the merchant id from
     * the ICSClient object.
     * @beaninfo hidden: false
     **/

    public void setMerchantIdPropertyName(String pMerchantIdPropertyName) {
        mMerchantIdPropertyName = pMerchantIdPropertyName;
    }
    
    /**
     * Get the name of the property from the ICSClient.props file that
     * specifies the MerchantId to use.
     * @beaninfo hidden: false
     **/

    public String getMerchantIdPropertyName() {
        return mMerchantIdPropertyName;
    }


    // Note: this member must be transient since ICSClient is not serializable
  
    public transient ICSClient mClient = null;
  
    /**
     * Return the ICSClient object for this connection, creating it if necessary.
     * @beaninfo ignore: true
     **/

    public ICSClient getICSClient()
    {
        // Since mClient is transient it's possible that if this object is
        // serialized and then deserialized, mClient will become null.  We
        // must therefore be prepared to reconstitute it here if necessary.
        // It would be nice if this method and doStartService could share
        // the same code but doStartService uses the properties file for
        // things other than just creating the client.

        try
        {
            if (mClient == null)
            {
                Properties props = new Properties();
                InputStream istr = new FileInputStream(getCsConfigFile()); 
                props.load(istr);
                istr.close();
                mClient = new ICSClient(props);
            }
        }
        catch (Exception e)
        {
            // In theory we might try to disable the CyberSourceConnection at
            // this point to prevent future attempts to do payment via CyberSource
            // and the possibility of a long sequence of errors.  We choose not
            // to do that on the theory that some failures may be transient, and
            // that even if one request fails a subsequent request may succeed.

            if (isLoggingError()) {
                Object[] args = { e.getMessage() };
                logError(msg.format("CyberSourceCreateClientFailed", args));
            }
        }

        return mClient;
    }
  
    
    /**
     * Create and return a new ICSClientRequest object for the ICSClient
     * used by this connection.
     * @beaninfo ignore: true
     **/
  
    public ICSClientRequest getICSClientRequest() throws ICSException {
        ICSClientRequest request = new ICSClientRequest(getICSClient());
  	if(getIgnoreAVS() != null)
            request.setField("ignore_avs", getIgnoreAVS());
	return request;
    }

  
    /**
     * Create and return a new ICSClientOffer
     * @beaninfo ignore: true
     **/

    public ICSClientOffer getICSClientOffer() throws ICSException {
        return new ICSClientOffer();
    }
    

    public String mIgnoreAVS = "";

    /**
     * Specify whether or not to add the ignore_avs field in the ICSClientRequest.
     * @beaninfo hidden: false
     **/
  
    public void setIgnoreAVS(String pIgnoreAVS) {
        mIgnoreAVS = pIgnoreAVS;
    }

    /**
     * Query whether or not to add the ignore_avs field in the ICSClientRequest
     * @beaninfo hidden: false
     **/
  
    public String getIgnoreAVS() {
        return mIgnoreAVS;
    }

    /**
     * @return a String representation of this object
     **/
    public String toString ()
    {
        StringBuffer buf = new StringBuffer ();
        buf.append (getClass ().getName ());
        buf.append ('[');
        buf.append (']');
        return buf.toString ();
    }

    //----------------------------------------
  
    /**
     * Initialize data structures when service is started.
     * @beaninfo hidden: false
     **/
  
    public void doStartService () throws ServiceException {

        isInitialized = false;

        // load ICSClient.props properties file
        // and build the ICSClient object
        try {
            Properties props = new Properties();
            InputStream istr = new FileInputStream(getCsConfigFile()); 
            props.load(istr);
            istr.close();
            mClient = new ICSClient(props);
            mMerchantId = props.getProperty(getMerchantIdPropertyName());
            isInitialized = true;
        }
        // check for any possible exceptions like FileNotFound, IO, ICS.
        catch(Exception except) {
            if (isLoggingError()) {
                Object[] args = { except.getMessage() };
                logError(msg.format("CyberSourceFailedInitialize", args));
            }
            throw new ServiceException(except.toString());
        }
        
        if (isInitialized)
            if (isLoggingInfo())
                logInfo(msg.getString("CyberSourceServiceStart"));
        
    }
    
    /**
     * Formats a double number, for example 5.08908 will
     * be formatted to 5.08
     * @beaninfo hidden: false
     **/
    public static double DoubleFormat(double a) {

        DecimalFormat format = (DecimalFormat)DecimalFormat.getInstance();
        format.setMaximumFractionDigits(2);
        format.setMinimumFractionDigits(2);
        format.setGroupingUsed(false);
        return Double.parseDouble(format.format(a));
        
    }


    /**
     * @return a CyberSourceStatus object with the error message
     * @beaninfo hidden: false
     **/
  
    public CyberSourceStatus processError(String pKey, String pMessage) {
        return processError(pKey, pMessage, 0);
    }
    
    /**
     * @return a CyberSourceStatus object with the error message
     * @beaninfo hidden: false
     **/ 
    public CyberSourceStatus processError(String pKey, String pMessage, double totald) {
        String error;
        
        if (pMessage != null)
            error = msg.format(pKey, pMessage);
        else
            error = msg.getString(pKey);
        if (isLoggingError()) {
            logError(error);
        }
        
        ICSReply reply = new ICSReply();
        reply.setField("error_mess_proc", error);
        if (totald != 0)
            reply.setField("total_amount", new Double(totald).toString());
        return new CyberSourceStatus(reply);
    }
}
