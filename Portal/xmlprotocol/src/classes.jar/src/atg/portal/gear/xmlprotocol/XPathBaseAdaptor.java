package atg.portal.gear.xmlprotocol;

/*<ATGCOPYRIGHT>

 * Copyright (C) 2001-2011 Art Technology Group, Inc.
 * All Rights Reserved.  No use, copying or distribution of this
 * work may be made except in accordance with a valid license
 * agreement from Art Technology Group.  This notice must be
 * included on all copies, modifications and derivatives of this
 * work.
 *
 * Art Technology Group (ATG) MAKES NO REPRESENTATIONS OR WARRANTIES
 * ABOUT THE SUITABILITY OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. ATG SHALL NOT BE
 * LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING,
 * MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
 *
 * Dynamo is a trademark of Art Technology Group, Inc.
 </ATGCOPYRIGHT>*/

/**
 * Serves as the base class for conversation adaptors generated by the gear's
 * XPath- and XSLT-based generator, implementing generic methods for handling
 * conversational state and semantics that can be applied to arbitrary service providers.
 * This base class supports all features of the XmlProtocol gear, including: state management;
 * headlines, categories, and article retrieval; personalization; and bookmarking/search forward.
 *
 * Adaptors are generated by creating an adaptor manifest file containing service provider
 * settings and XPath expressions for evaluating response messages.  An XSLT stylsheet
 * will transform the manifest into a Java class extending XPathBaseAdaptor.  The class may
 * then be plugged into the XmlProtocol gear framework.
 *
 * This class uses the Jaxen XPath compiler (www.jaxen.org) to evaluate arbitrary
 * XML documents returned from the service provider.  Jaxen is the XPath engine
 * used by the DOM4J project but is parser-independent and can be used with a number
 * of parsers and a variety of object models including DOM, DOM4J, and JDOM.
 */

import javax.servlet.jsp.*;
import javax.servlet.jsp.tagext.*;
import java.io.*;
import java.net.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Iterator;

import org.w3c.dom.Document;
import org.w3c.dom.DocumentType;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Element;

import atg.xml.tools.XMLToolsFactory;
import atg.xml.XMLFileEntityResolver;
import atg.xml.tools.XMLToDOMParser;
import atg.core.util.StringUtils;
import atg.core.net.URLUtils;

/*  Classes to use Jaxen as the XPath compiler (www.jaxen.org) instead of Xalan
import org.jaxen.dom.XPath;
import org.jaxen.JaxenException;
import org.saxpath.SAXPathException;
import org.saxpath.XPathSyntaxException;
*/

import atg.apache.xpath.*;
import atg.apache.xpath.objects.*;
import org.w3c.dom.traversal.NodeIterator;
import org.w3c.dom.Attr;
import javax.xml.transform.TransformerException;


/**
 * @version $Id: //app/portal/version/10.0.3/xmlprotocol/classes.jar/src/atg/portal/gear/xmlprotocol/XPathBaseAdaptor.java#2 $$Change: 651448 $
 * @updated $DateTime: 2011/06/07 13:55:45 $$Author: rbarbier $
 */
public abstract class XPathBaseAdaptor extends XmlConversationAdaptor{

  //-------------------------------------
  /** Class version string */

  public static String CLASS_VERSION = "$Id: //app/portal/version/10.0.3/xmlprotocol/classes.jar/src/atg/portal/gear/xmlprotocol/XPathBaseAdaptor.java#2 $$Change: 651448 $";


  public static String ADAPTOR_DESCRIPTION              = "Base class for auto-generated adaptors";
  public static String ADAPTOR_VERSION                  = "1.0";

  //XPath expressions for parsing responses
  public static String XPATH_RESPONSE_ERROR_MSG;
  public static String XPATH_AUTHENTICATION_STATUS;
  public static String XPATH_AUTHENTICATION_ERROR_MSG;
  public static String XPATH_SESSION_ID;
  public static String XPATH_CATEGORY_NAMES;
  public static String XPATH_CATEGORY_IDS;
  public static String XPATH_BOOKMARKS;

  //XML response values - NOTE: these should be overriden by the sublcass
  public static int AUTHENTICATION_STATUS_OK       = 0;
  public static final int STATUS_OK                = 0;
  public static final int STATUS_FAIL              = -1;
  public static final int AUTH_STATEFULL           = 1;
  public static final int AUTH_STATELESS           = 2;
  public static final int AUTH_NONE                = 3;


  //URL param names - NOTE: these should be overriden by the sublcass

  public static String USER_ID                     = "USER_ID";
  public static String PASSWORD                    = "PASSWORD";

  /**
   *   We need to have begin and end tags for categories since some providers
   *   implement APIs where categories are not specified by 'name=value'
   *   but part of a search expression such as 'critieria=[categories=1 AND 2]'
   */

  public static String CATEGORIES_BEGIN            = "FOLDER_ID";
  public static String CATEGORIES_END              = "";

  public static String NUM_HEADLINES               = "NUM_HEADLINES";
  public static String BOOKMARKS                   = "BOOKMARKS";
  public static String ARTICLE_ID                  = "ARTICLE_ID";
  public static String SESSION_ID                  = "SESSION_ID";

  public static String BOOKMARKS_SEPARATOR         = ",";

  public static String HEADLINES_PARAMS            = "";
  public static String CATEGORY_PARAMS             = "";
  public static String ARTICLE_PARAMS              = "";
  public static String AUTHENTICATE_PARAMS         = "";

  public static int AUTHENTICATION_TYPE            = AUTH_STATEFULL;

  // set some things as basic defaults
  String mAuthenticationUrl;
  String mCategoriesUrl;
  String mHeadlinesUrl;
  String mArticleUrl;

  // the Session Id for the service provider
  protected final static int XMLPROTOCOL_XPATHBASEADAPTOR_SESSION_ID = 0;

  private String mSid;

  //-------------------------------------
  // Methods

  /**
   * Empty constructor to support dynamic class loading
   */
  public XPathBaseAdaptor() {}

  /**
   * Indicates whether service provider requires a separate (stateful) authentication request
   * or credentials are given for each request (stateless).
   *
   * NOTE: this method should be overriden
   */


  protected int getAuthenticationType(){
    return AUTHENTICATION_TYPE;
  }
  /**
   * Initializes the class.  This method must be called after constructing the object
   *
   * @param pPageContext for storing stateful information
   *
   * @exception Exception if there is a problem initializing
   */
  public void init(PageContext pPageContext) throws Exception{
    super.init(pPageContext);
  }

  /**
   * Determines whether the client (e.g. a gear) session has already authenticated
   * with the service
   *
   * @returns true if the client is already authenticated
   */
  private boolean getAuthenticated(){
    if (mSid == null){
      //We store the session ID in the user's session and keep it locally
      //here to make access cleaner
      mSid = (String) mPageContext.getSession().getAttribute("XMLPROTOCOL_XPATHBASEADAPTOR_SESSION_ID");
      if(isLoggingDebug()){
        logDebug(this.getName()+": looking up session id:" + mSid);
      }
      if (mSid == null){
        return false;
      }
    }
    return true;
  }

  /**
   * A convenience method for authenticating with the service.
   * The userID and password must be set prior to invoking this method.
   *
   * @returns METHOD_FAIL or METHOD_SUCCESS
   */
  public int authenticate() throws ConversationException{
    if (this.getAuthenticationType() == AUTH_STATELESS || this.getAuthenticationType() == AUTH_NONE){
      return METHOD_SUCCESS;
    }
    if (this.getUserID() == null || this.getPassword() == null){
      throw new ConversationException("User Name or password not set");
    }
    return this.authenticate(mUserID,mPassword);
  }

  /**
   * Authenticates with the service provider
   *
   * @param UserID and Password to pass as credentials to the service provider
   *
   * @returns METHOD_FAIL or METHOD_SUCCESS
   *
   */

  public int authenticate(String pUserID, String pPassword) throws ConversationException{
   try{

        //if we are doing state less authentication just return
        if (this.getAuthenticationType() == AUTH_STATELESS || this.getAuthenticationType() == AUTH_NONE){
          return METHOD_SUCCESS;
        }

        //construct the authentication URL including the query string.  This will correspond
        //to the service provider's HTTP GET/POST - based authentication API.
        Document theResponse;
        StringBuffer queryString = new StringBuffer();
        queryString.append("?"+USER_ID+"=" + URLUtils.escapeUrlString(pUserID));
        if (!StringUtils.isEmpty(PASSWORD)){
          queryString.append("&"+PASSWORD+"="+URLUtils.escapeUrlString(pPassword));
        }
        if (!StringUtils.isEmpty(AUTHENTICATE_PARAMS)){
          queryString.append("&"+AUTHENTICATE_PARAMS);
        }
        String theUrl = this.getAuthenticationUrl() + queryString.toString();

        /**
         * Connect to the provider and make sure we do not cache the result (since we are
         * not passing any cache key, we are indicating we do not want it for this request)
         */
        theResponse = this.connect(theUrl);

        //make sure we have a response
        if (theResponse == null){
           if(isLoggingError()){
            logDebug(this.getName()+": error authenticating - no document received from the provider service");
          }
          return METHOD_FAIL;
        }

        XPathAPI xpath = new XPathAPI();
        XObject xo = xpath.eval(theResponse.getDocumentElement(),XPATH_AUTHENTICATION_STATUS);
        int statusCode = -1;
        if (xo.getType() == XObject.CLASS_STRING){
           statusCode = Integer.parseInt(xo.str());
        }else if(xo.getType() == XObject.CLASS_NODESET) {
          NodeIterator ni = xo.nodeset();

          Node theNode;
          NodeList ns = xo.nodelist();

          for (int x=0;x<ns.getLength();x++){
            theNode = ns.item(x);
            if (theNode.getNodeType() == Node.ATTRIBUTE_NODE){
               statusCode = Integer.parseInt(((Attr)theNode).getNodeValue());
            }else{
              statusCode = Integer.parseInt(((Element)ns.item(x)).getFirstChild().getNodeValue());
            }
          }
        }


/* This uses jaxen
        XPath xpath = new XPath(XPATH_AUTHENTICATION_STATUS);
        int statusCode = Integer.parseInt(xpath.valueOf(theResponse));
*/
        if (statusCode == AUTHENTICATION_STATUS_OK){
           if (isLoggingDebug()){
             logDebug(this.getName()+": successful authentication");
           }


          xo = xpath.eval(theResponse.getDocumentElement(),XPATH_SESSION_ID);
          if (xo.getType() == XObject.CLASS_STRING){
             mSid = xo.str();

          }else if(xo.getType() == XObject.CLASS_NODESET) {
            NodeIterator ni = xo.nodeset();

            Node theNode;
            NodeList ns = xo.nodelist();

            for (int x=0;x<ns.getLength();x++){
              theNode = ns.item(x);
              if (theNode.getNodeType() == Node.ATTRIBUTE_NODE){
                 mSid = ((Attr)theNode).getNodeValue();
              }else{
                mSid = ((Element)ns.item(x)).getFirstChild().getNodeValue();
              }
            }
          }
          /* jaxen code
           xpath = new XPath(XPATH_SESSION_ID);
           mSid = xpath.valueOf(theResponse);
           */
           mPageContext.getSession().setAttribute("XMLPROTOCOL_XPATHBASEADAPTOR_SESSION_ID",mSid);
           return METHOD_SUCCESS;
        }else{  //error reported
            StringBuffer strBuff = new StringBuffer();
            xo = xpath.eval(theResponse.getDocumentElement(),XPATH_AUTHENTICATION_ERROR_MSG);
            if (xo.getType() == XObject.CLASS_STRING){
              strBuff.append(xo.str()+"\n");
              //strBuff.append("\n");
            }else if(xo.getType() == XObject.CLASS_NODESET) {
              NodeIterator ni = xo.nodeset();
              Node theNode;
              NodeList ns = xo.nodelist();
              for (int x=0;x<ns.getLength();x++){
                theNode = ns.item(x);
                if (theNode.getNodeType() == Node.ATTRIBUTE_NODE){
                   strBuff.append(((Attr)theNode).getNodeValue()+"\n");
                }else{
                  strBuff.append(((Element)ns.item(x)).getFirstChild().getNodeValue()+"\n");
                }
              }
            }

          /* jaxen code
           xpath = new XPath(XPATH_AUTHENTICATION_ERROR_MSG);
           List nodeList = xpath.selectNodes(theResponse);
           Iterator resultIter = nodeList.iterator();
           StringBuffer strBuff = new StringBuffer();
           while (resultIter.hasNext()){
              Node node = (Node)resultIter.next();
              if (node.getNodeType() == Node.ELEMENT_NODE){
                strBuff.append(((Element)node).getFirstChild().getNodeValue());
                strBuff.append("\n");
              }else if (node.getNodeType() == Node.ATTRIBUTE_NODE) {
                strBuff.append(node.getNodeValue());
                strBuff.append("\n");
              }
           }*/
           if (isLoggingDebug()){
            logDebug(this.getName()+": error authenticating with thea service provider \n Code: "+ statusCode +"\nMessage(s): \n" + strBuff.toString() );
           }
           return METHOD_FAIL;
        }
    }catch (TransformerException e){
      throw new ConversationException(e);

    }
  }

  Document mXMLHeadlines;

  /**
   * This method returns the Headlines as a DOM object after retrieveHeadlines()
   * called.
   *
   * @returns org3.w3c.Document
   */
  public Document getXMLHeadlines(){
    return mXMLHeadlines;
  }

  private void setXMLHeadlines(Document pXMLHeadlines){
    mXMLHeadlines = pXMLHeadlines;
  }

  Document mXMLCategories;

  public Document getXMLCategories(){
    return mXMLCategories;
  }

  private void setXMLCategories(Document pXMLCategories){
    mXMLCategories = pXMLCategories;
  }

  /**
   * Returns a list of category names the user is entitled to from a service
   * provider.
   */
  public String[] getCategoryNames(){
    return this.getCategoryItems(XPATH_CATEGORY_NAMES);
  }

  /**
  * Returns a list of category ids corresponding to category names the user is
  * entitled to from a service provider.
  */

  public String[] getCategoryIDs(){
    return this.getCategoryItems(XPATH_CATEGORY_IDS);
  }

  /**
   * A generic routine for parsing information about category items returned by
   * the service provider
   */
  protected String[] getCategoryItems(String pExpression){
    try{
      if (mXMLCategories != null){
          XPathAPI xpath = new XPathAPI();
          XObject xo = xpath.eval(mXMLCategories,pExpression);
          String[] theCategories = null;
          if(xo.getType() == XObject.CLASS_NODESET) {

            NodeIterator ni = xo.nodeset();

            Node theNode;
            NodeList ns = xo.nodelist();
            theCategories = new String[ns.getLength()];
            StringBuffer strBuff = new StringBuffer();

            for (int x=0;x<ns.getLength();x++){
              theNode = ns.item(x);
              if (theNode.getNodeType() == Node.ATTRIBUTE_NODE){
                 theCategories[x] = ((Attr)theNode).getNodeValue();
              }else{
                 theCategories[x] = ((Element)ns.item(x)).getFirstChild().getNodeValue();
              }
            }
          }
        /* jaxen code
        XPath xpath = new XPath(pExpression);
        List nodeList = xpath.selectNodes(mXMLCategories);
        String[] theCategories = new String[nodeList.size()];
        Iterator resultIter = nodeList.iterator();
        StringBuffer strBuff = new StringBuffer();
        int i = 0;
        while (resultIter.hasNext()){
            Node node = (Node)resultIter.next();
            if (node.getNodeType() == Node.ELEMENT_NODE){
              theCategories[i] = ((Element)node).getFirstChild().getNodeValue();
            }else if (node.getNodeType() == Node.ATTRIBUTE_NODE) {
              theCategories[i] = node.getNodeValue();
            }
            i++;
        }*/
        return theCategories;
      }else{
        return null;
      }
    }catch (TransformerException e){
      if (this.isLoggingError()){
        this.logError(this.getName()+": Error parsing category names:",e);
      }
      return null;
    }
 }


  Document mXMLArticle;

  public Document getXMLArticle(){
    return mXMLArticle;
  }

  private void setXMLArticle(Document pXMLArticle){
    mXMLArticle = pXMLArticle;
  }

  String mBookmarks = "";
  public String getBookmarks(){
    return mBookmarks;
  }
  public void setBookmarks(String pBookmarks){
    mBookmarks = pBookmarks;
  }

  /**
   * Convenience method for retrieveHeadlines with no parameters
   */
    public void retrieveHeadlines() throws ConversationException{
      this.retrieveHeadlines(null);
    }

  /**
   * Retrieves news headlines from the service and stores the in the XMLHeadlines
   * property.  If the client session is not authenticated, the method will try to do so.
   *
   * @exception ConversationException if there is an error communicating with the service.
   *
   */

    public void retrieveHeadlines(ArrayList pParameterList) throws ConversationException{
      Document theResponse;

      mRequestCacheExpiration = mAdaptorConfig.getCacheHeadlines();

      /**
       * Default to no search continuation, i.e. we are not searching from a
       * previously bookmarked position.
       *
       * We also need to substitute the generic gear paramter names with
       * provider-specific ones.
       */
      if (pParameterList != null){
        int paramSize = pParameterList.size();
        String theValue;
        for (int i=0; i< paramSize; i++){
            theValue = (String) pParameterList.get(i);
             if (theValue.startsWith(PARAM_FEED_CATEGORIES+"=")){
              pParameterList.set(i,CATEGORIES_BEGIN+"="+URLUtils.escapeUrlString(theValue.substring(theValue.indexOf("=")+1))+CATEGORIES_END);
            }else if (theValue.startsWith(PARAM_NUM_HEADLINES+"=")){
              pParameterList.set(i,NUM_HEADLINES+"="+theValue.substring(theValue.indexOf("=")+1));
            }else if (theValue.startsWith(PARAM_HEADLINES_BOOKMARKS+"=")){
              pParameterList.set(i,BOOKMARKS+"="+theValue.substring(theValue.indexOf("=")+1));
            }else{
              //We do not have a mapping for this param name so pass it through
              pParameterList.set(i,theValue);
            }
         }
        if (!StringUtils.isEmpty(HEADLINES_PARAMS)){
          pParameterList.add(HEADLINES_PARAMS);
        }
        theResponse = this.retrieveHandler(pParameterList, getHeadlinesUrl());
      }else{
        if (!StringUtils.isEmpty(HEADLINES_PARAMS)){
          pParameterList = new ArrayList();
          pParameterList.add(HEADLINES_PARAMS);
          theResponse = this.retrieveHandler(pParameterList, getHeadlinesUrl());
        }else{
          theResponse = this.retrieveHandler(null, getHeadlinesUrl());
        }
      }
      if(theResponse != null){
        //get bookmarks and save for continuation search in the session object
         try{
           XPathAPI xpath = new XPathAPI();
           XObject xo = xpath.eval(theResponse,XPATH_BOOKMARKS);
           if(xo.getType() == XObject.CLASS_NODESET) {
              NodeIterator ni = xo.nodeset();
              Node theNode;
              NodeList ns = xo.nodelist();
              StringBuffer theBooks = new StringBuffer();
              for (int x=0;x<ns.getLength()-1;x++){
                theNode = ns.item(x);
                if (theNode.getNodeType() == Node.ATTRIBUTE_NODE){
                   theBooks.append(((Attr)theNode).getNodeValue()+ BOOKMARKS_SEPARATOR);
                }else{
                   theBooks.append(((Element)ns.item(x)).getFirstChild().getNodeValue()+BOOKMARKS_SEPARATOR);
                }
              }
              if (ns.getLength() >= 1){
                 theNode = ns.item(ns.getLength()-1);
                 if (theNode.getNodeType() == Node.ATTRIBUTE_NODE){
                    theBooks.append(((Attr)theNode).getNodeValue());
                 }else{
                    theBooks.append(((Element)ns.item(ns.getLength()-1)).getFirstChild().getNodeValue());
                 }
                this.setBookmarks(theBooks.toString());
              }
           }
          /* jaxen code
           XPath xpath = new XPath(XPATH_BOOKMARKS);
           List nodeList = xpath.selectNodes(theResponse);
           //Iterator resultIter = nodeList.iterator();
           StringBuffer theBooks = new StringBuffer();
           int nodeLen = nodeList.size();
           Node node;

           for (int i=0; i<nodeLen-1;i++){
              node = (Node)nodeList.get(i);
              if (node.getNodeType() == Node.ELEMENT_NODE){
                theBooks.append(((Element)node).getFirstChild().getNodeValue()+ BOOKMARKS_SEPARATOR);
              }else if (node.getNodeType() == Node.ATTRIBUTE_NODE) {
                theBooks.append(node.getNodeValue()+BOOKMARKS_SEPARATOR);
              }
           }
            // we do not want to put a separator on the last bookmark
           if (nodeLen >= 1){
              node = (Node)nodeList.get(nodeLen-1);
              if (node.getNodeType() == Node.ELEMENT_NODE){
                theBooks.append(((Element)node).getFirstChild().getNodeValue());
               }else if (node.getNodeType() == Node.ATTRIBUTE_NODE) {
                theBooks.append(node.getNodeValue());
              }
             this.setBookmarks(theBooks.toString());
           }

          */
         }catch (TransformerException e){
           if (this.isLoggingError()){
              this.logError("Error reading bookmarks: ", e);
           }
         }
        this.setXMLHeadlines(theResponse);
      }
    }

   /**
    * Convenience method for retrieveHeadlines with no parameters
    */
    public void retrieveCategories() throws ConversationException{
      this.retrieveCategories(null);
    }

    /**
     * Retrieves news categories from the service and stores the in the XMLCategories
     * property.  If the client session is not authenticated, the method will try to do so.
     *
     * @exception ConversationException if there is an error communicating with the service.
     *
     */
      public void retrieveCategories(ArrayList pParameterList) throws ConversationException{
        Document theResponse;
        mRequestCacheExpiration = mAdaptorConfig.getCacheCategories();

        if (pParameterList == null){
          if (!StringUtils.isEmpty(CATEGORY_PARAMS)){
            pParameterList = new ArrayList();
            pParameterList.add(CATEGORY_PARAMS);
          }
        }else{
          if (!StringUtils.isEmpty(CATEGORY_PARAMS)){
            pParameterList.add(CATEGORY_PARAMS);
          }
        }
        theResponse = this.retrieveHandler(pParameterList, getCategoriesUrl());
        if(theResponse != null){
          this.setXMLCategories(theResponse);
        }
    }

    /**
     * Convenience method for retrieveHeadlines with no parameters
     */

    public void retrieveArticle(String pArticleID) throws ConversationException{
      this.retrieveArticle(pArticleID, null);
    }

    /**
     * Retrieves a specific new article from the service and stores the in the XMLArticle
     * property.  If the client session is not authenticated, the method will try to do so.
     *
     * @exception ConversationException if there is an error communicating with the service.
     *
     */

    public void retrieveArticle(String pArticleID, ArrayList pParameterList) throws ConversationException{
      if (pParameterList == null){
        pParameterList = new ArrayList();
      }
      pParameterList.add(ARTICLE_ID+"="+URLUtils.escapeUrlString(pArticleID));
      if (!StringUtils.isEmpty(ARTICLE_PARAMS)){
        pParameterList.add(ARTICLE_PARAMS);
      }
      mRequestCacheExpiration = mAdaptorConfig.getCacheArticles();
      Document theResponse = this.retrieveHandler(pParameterList, getArticleUrl());
      if(theResponse != null){
        this.setXMLArticle(theResponse);
      }
    }

    /**
     * This methods handles the generic communications process with the service for
     * authenticating, retrieving categories, retrieving headlines, and retrieving articles
     *
     * We are assuming that authentication will be done directly through connect()
     * with no caching.  All other requests will be cached by default.
     *
     * @returns a DOM object representing the information received from the service
     */
    private Document retrieveHandler(ArrayList pParameterList, String pUrl) throws ConversationException{
      Document theResponse;
      int n;

      if (this.getAuthenticationType() == AUTH_STATEFULL){
          //check to see if we have authenticated with the service
          if (!this.getAuthenticated()){
             n=1;
             int retries =  mNumRetries;
             while (n<=retries){
                if (isLoggingDebug()){
                   logDebug(this.getName()+": trying to authenticate attempt " + n);
                }
                if (this.authenticate() == METHOD_SUCCESS){
                   if (isLoggingDebug()){
                       logDebug(this.getName()+": authenticate success");
                    }
                    break;
                }
                n++;
             }
            if (!this.getAuthenticated()){
              throw new ConversationException(this.getName()+": maximum retries to authenticate exceeded");
            }
          }
      }

      //construct the query string and cache id.  The cache id is the URL without the session id
      StringBuffer cacheIDParams = new StringBuffer();
      StringBuffer queryString = new StringBuffer();
      if (this.getAuthenticationType() == AUTH_STATELESS){
        queryString.append("?"+USER_ID+"="+URLUtils.escapeUrlString(this.getUserID()));
      }else if (this.getAuthenticationType() == AUTH_STATEFULL){
        queryString.append("?"+SESSION_ID+"="+mSid);    //we always need to pass session id...
      }else{
        queryString.append("?");
      }
      //convert the parameter list to a query string
      if (pParameterList != null){
        cacheIDParams.append(this.makeUrlParams(pParameterList));
        queryString.append(this.makeUrlParams(pParameterList));
      }
     // String cacheID = pUrl+cacheIDParams.toString();

      n=1;
      //we now try to retrieve the document the specified number of times
      int status;
      //int retries = this.getNumRetries();
      String theUrl = pUrl+queryString.toString();
      if (isLoggingDebug()){
          logDebug(this.getName()+": url attempting to get: " +theUrl);
      }
      while (n<=mNumRetries){
        theResponse = this.connect(theUrl,theUrl);
        if (theResponse != null){
          status = this.getStatusCode(theResponse);
          if (status !=STATUS_OK){
            //TODO: check error message values before attempting to reauthenticate
            //We received an error.  See if session has expired.  If so, try re-authenticating and request the document again
            if (isLoggingDebug()){
              logDebug(this.getName()+": error retrieving document from the service: \n Code: " + status);
            }
            this.authenticate();
          }else{
            return theResponse;
          }
        }
        if (isLoggingDebug()){
          logDebug(this.getName()+": document retry retrieval attempt " + n );
        }
        n++;
      }
      if (isLoggingError()){
          logError(this.getName()+": error retrieving document - maximum retries exceeded." );
      }
      throw new ConversationException(this.getName()+": error retrieving document - maximum retries exceeded");  //assume a failure
    }

    /**
     * Determines if the provider supports headline retrieval accross more than one category
     */
    public boolean supportsMultipleCategories(){
      return true;
    }

    /**
     * Determines whether to cache the results.
     * We base our assumption on the existence of an error message in
     * the response document.
     */

    protected long shouldCache(Document theResponse){
      int status = this.getStatusCode(theResponse);
      if (status == STATUS_OK){
         return mRequestCacheExpiration;
      }else{
        return NO_CACHE;
      }
    }

    /**
     * Checks for the existance of error messages in a document
     *
     * @parma Document the Document to check
     */
    private int getStatusCode(Document pDoc){
      try{
        XPathAPI xpath = new XPathAPI();
        XObject xo = xpath.eval(pDoc,XPATH_RESPONSE_ERROR_MSG);
        if(xo.getType() == XObject.CLASS_NODESET) {
          NodeList ns = xo.nodelist();
          Node theNode;
          if (ns.getLength() > 0){
            if (this.isLoggingError()){
              for (int x=0;x<ns.getLength();x++){
                theNode = ns.item(x);
                if (theNode.getNodeType() == Node.ATTRIBUTE_NODE){
                   this.logError(((Attr)theNode).getNodeValue());
                }else{
                  this.logError(((Element)ns.item(x)).getFirstChild().getNodeValue());
                }
              }
            }
          return STATUS_FAIL;
        }else{
          return STATUS_OK;
        }
        }else{
          return STATUS_FAIL;
        }
        /* jaxen code
        XPath xpath = new XPath(XPATH_RESPONSE_ERROR_MSG);
        List nodeList = xpath.selectNodes(pDoc);
        if (nodeList.size() > 0) {
          if (this.isLoggingError()){
            Iterator resultIter = nodeList.iterator();
            while (resultIter.hasNext()){
                Node node = (Node)resultIter.next();
                if (node.getNodeType() == Node.ELEMENT_NODE){
                  this.logError(((Element)node).getFirstChild().getNodeValue());
                }else if (node.getNodeType() == Node.ATTRIBUTE_NODE) {
                  this.logError(node.getNodeValue());
                }
            }
          }
          return STATUS_FAIL;
        }else{
          return STATUS_OK;
        }*/
      }catch( TransformerException e){
        if (this.isLoggingError()){
          this.logError(this.getName()+": Error parsing response status", e);
        }
        return STATUS_FAIL;
      }
    }

}
